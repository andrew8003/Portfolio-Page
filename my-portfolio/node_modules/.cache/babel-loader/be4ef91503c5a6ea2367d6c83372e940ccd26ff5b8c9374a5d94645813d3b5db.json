{"ast":null,"code":"// Include `data` fields in mdast and `raw` nodes in hast.\n/// <reference types=\"mdast-util-to-hast\" />\n\n/**\r\n * @typedef {import('hast').Root} HastRoot\r\n * @typedef {import('mdast').Root} MdastRoot\r\n * @typedef {import('mdast-util-to-hast').Options} ToHastOptions\r\n * @typedef {import('unified').Processor} Processor\r\n * @typedef {import('vfile').VFile} VFile\r\n */\n\n/**\r\n * @typedef {Omit<ToHastOptions, 'file'>} Options\r\n *\r\n * @callback TransformBridge\r\n *   Bridge-mode.\r\n *\r\n *   Runs the destination with the new hast tree.\r\n *   Discards result.\r\n * @param {MdastRoot} tree\r\n *   Tree.\r\n * @param {VFile} file\r\n *   File.\r\n * @returns {Promise<undefined>}\r\n *   Nothing.\r\n *\r\n * @callback TransformMutate\r\n *  Mutate-mode.\r\n *\r\n *  Further transformers run on the hast tree.\r\n * @param {MdastRoot} tree\r\n *   Tree.\r\n * @param {VFile} file\r\n *   File.\r\n * @returns {HastRoot}\r\n *   Tree (hast).\r\n */\n\nimport { toHast } from 'mdast-util-to-hast';\n\n/**\r\n * Turn markdown into HTML.\r\n *\r\n * ##### Notes\r\n *\r\n * ###### Signature\r\n *\r\n * *   if a processor is given, runs the (rehype) plugins used on it with a\r\n *     hast tree, then discards the result (*bridge mode*)\r\n * *   otherwise, returns a hast tree, the plugins used after `remarkRehype`\r\n *     are rehype plugins (*mutate mode*)\r\n *\r\n * > ðŸ‘‰ **Note**: Itâ€™s highly unlikely that you want to pass a `processor`.\r\n *\r\n * ###### HTML\r\n *\r\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\r\n * as semistandard `raw` nodes.\r\n * Most plugins ignore `raw` nodes but two notable ones donâ€™t:\r\n *\r\n * *   `rehype-stringify` also has an option `allowDangerousHtml` which will\r\n *     output the raw HTML.\r\n *     This is typically discouraged as noted by the option name but is useful if\r\n *     you completely trust authors\r\n * *   `rehype-raw` can handle the raw embedded HTML strings by parsing them\r\n *     into standard hast nodes (`element`, `text`, etc).\r\n *     This is a heavy task as it needs a full HTML parser, but it is the only way\r\n *     to support untrusted content\r\n *\r\n * ###### Footnotes\r\n *\r\n * Many options supported here relate to footnotes.\r\n * Footnotes are not specified by CommonMark, which we follow by default.\r\n * They are supported by GitHub, so footnotes can be enabled in markdown with\r\n * `remark-gfm`.\r\n *\r\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\r\n * that explains footnotes, which is hidden for sighted users but shown to\r\n * assistive technology.\r\n * When your page is not in English, you must define translated values.\r\n *\r\n * Back references use ARIA attributes, but the section label itself uses a\r\n * heading that is hidden with an `sr-only` class.\r\n * To show it to sighted users, define different attributes in\r\n * `footnoteLabelProperties`.\r\n *\r\n * ###### Clobbering\r\n *\r\n * Footnotes introduces a problem, as it links footnote calls to footnote\r\n * definitions on the page through `id` attributes generated from user content,\r\n * which results in DOM clobbering.\r\n *\r\n * DOM clobbering is this:\r\n *\r\n * ```html\r\n * <p id=x></p>\r\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\r\n * ```\r\n *\r\n * Elements by their ID are made available by browsers on the `window` object,\r\n * which is a security risk.\r\n * Using a prefix solves this problem.\r\n *\r\n * More information on how to handle clobbering and the prefix is explained in\r\n * *Example: headings (DOM clobbering)* in `rehype-sanitize`.\r\n *\r\n * ###### Unknown nodes\r\n *\r\n * Unknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\r\n * The default behavior for unknown nodes is:\r\n *\r\n * *   when the node has a `value` (and doesnâ€™t have `data.hName`,\r\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\r\n *     node\r\n * *   otherwise, create a `<div>` element (which could be changed with\r\n *     `data.hName`), with its children mapped from mdast to hast as well\r\n *\r\n * This behavior can be changed by passing an `unknownHandler`.\r\n *\r\n * @overload\r\n * @param {Processor} processor\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n * @returns {TransformBridge}\r\n *\r\n * @overload\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n * @returns {TransformMutate}\r\n *\r\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\r\n *   Processor or configuration (optional).\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n *   When a processor was given, configuration (optional).\r\n * @returns {TransformBridge | TransformMutate}\r\n *   Transform.\r\n */\nexport default function remarkRehype(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\r\n     * @type {TransformBridge}\r\n     */\n    return async function (tree, file) {\n      // Cast because root in -> root out.\n      const hastTree = /** @type {HastRoot} */\n      toHast(tree, {\n        file,\n        ...options\n      });\n      await destination.run(hastTree, file);\n    };\n  }\n\n  /**\r\n   * @type {TransformMutate}\r\n   */\n  return function (tree, file) {\n    // Cast because root in -> root out.\n    return /** @type {HastRoot} */toHast(tree, {\n      file,\n      ...(options || destination)\n    });\n  };\n}","map":{"version":3,"names":["toHast","remarkRehype","destination","options","tree","file","hastTree","run"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/remark-rehype/lib/index.js"],"sourcesContent":["// Include `data` fields in mdast and `raw` nodes in hast.\r\n/// <reference types=\"mdast-util-to-hast\" />\r\n\r\n/**\r\n * @typedef {import('hast').Root} HastRoot\r\n * @typedef {import('mdast').Root} MdastRoot\r\n * @typedef {import('mdast-util-to-hast').Options} ToHastOptions\r\n * @typedef {import('unified').Processor} Processor\r\n * @typedef {import('vfile').VFile} VFile\r\n */\r\n\r\n/**\r\n * @typedef {Omit<ToHastOptions, 'file'>} Options\r\n *\r\n * @callback TransformBridge\r\n *   Bridge-mode.\r\n *\r\n *   Runs the destination with the new hast tree.\r\n *   Discards result.\r\n * @param {MdastRoot} tree\r\n *   Tree.\r\n * @param {VFile} file\r\n *   File.\r\n * @returns {Promise<undefined>}\r\n *   Nothing.\r\n *\r\n * @callback TransformMutate\r\n *  Mutate-mode.\r\n *\r\n *  Further transformers run on the hast tree.\r\n * @param {MdastRoot} tree\r\n *   Tree.\r\n * @param {VFile} file\r\n *   File.\r\n * @returns {HastRoot}\r\n *   Tree (hast).\r\n */\r\n\r\nimport {toHast} from 'mdast-util-to-hast'\r\n\r\n/**\r\n * Turn markdown into HTML.\r\n *\r\n * ##### Notes\r\n *\r\n * ###### Signature\r\n *\r\n * *   if a processor is given, runs the (rehype) plugins used on it with a\r\n *     hast tree, then discards the result (*bridge mode*)\r\n * *   otherwise, returns a hast tree, the plugins used after `remarkRehype`\r\n *     are rehype plugins (*mutate mode*)\r\n *\r\n * > ðŸ‘‰ **Note**: Itâ€™s highly unlikely that you want to pass a `processor`.\r\n *\r\n * ###### HTML\r\n *\r\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\r\n * as semistandard `raw` nodes.\r\n * Most plugins ignore `raw` nodes but two notable ones donâ€™t:\r\n *\r\n * *   `rehype-stringify` also has an option `allowDangerousHtml` which will\r\n *     output the raw HTML.\r\n *     This is typically discouraged as noted by the option name but is useful if\r\n *     you completely trust authors\r\n * *   `rehype-raw` can handle the raw embedded HTML strings by parsing them\r\n *     into standard hast nodes (`element`, `text`, etc).\r\n *     This is a heavy task as it needs a full HTML parser, but it is the only way\r\n *     to support untrusted content\r\n *\r\n * ###### Footnotes\r\n *\r\n * Many options supported here relate to footnotes.\r\n * Footnotes are not specified by CommonMark, which we follow by default.\r\n * They are supported by GitHub, so footnotes can be enabled in markdown with\r\n * `remark-gfm`.\r\n *\r\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\r\n * that explains footnotes, which is hidden for sighted users but shown to\r\n * assistive technology.\r\n * When your page is not in English, you must define translated values.\r\n *\r\n * Back references use ARIA attributes, but the section label itself uses a\r\n * heading that is hidden with an `sr-only` class.\r\n * To show it to sighted users, define different attributes in\r\n * `footnoteLabelProperties`.\r\n *\r\n * ###### Clobbering\r\n *\r\n * Footnotes introduces a problem, as it links footnote calls to footnote\r\n * definitions on the page through `id` attributes generated from user content,\r\n * which results in DOM clobbering.\r\n *\r\n * DOM clobbering is this:\r\n *\r\n * ```html\r\n * <p id=x></p>\r\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\r\n * ```\r\n *\r\n * Elements by their ID are made available by browsers on the `window` object,\r\n * which is a security risk.\r\n * Using a prefix solves this problem.\r\n *\r\n * More information on how to handle clobbering and the prefix is explained in\r\n * *Example: headings (DOM clobbering)* in `rehype-sanitize`.\r\n *\r\n * ###### Unknown nodes\r\n *\r\n * Unknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\r\n * The default behavior for unknown nodes is:\r\n *\r\n * *   when the node has a `value` (and doesnâ€™t have `data.hName`,\r\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\r\n *     node\r\n * *   otherwise, create a `<div>` element (which could be changed with\r\n *     `data.hName`), with its children mapped from mdast to hast as well\r\n *\r\n * This behavior can be changed by passing an `unknownHandler`.\r\n *\r\n * @overload\r\n * @param {Processor} processor\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n * @returns {TransformBridge}\r\n *\r\n * @overload\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n * @returns {TransformMutate}\r\n *\r\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\r\n *   Processor or configuration (optional).\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n *   When a processor was given, configuration (optional).\r\n * @returns {TransformBridge | TransformMutate}\r\n *   Transform.\r\n */\r\nexport default function remarkRehype(destination, options) {\r\n  if (destination && 'run' in destination) {\r\n    /**\r\n     * @type {TransformBridge}\r\n     */\r\n    return async function (tree, file) {\r\n      // Cast because root in -> root out.\r\n      const hastTree = /** @type {HastRoot} */ (\r\n        toHast(tree, {file, ...options})\r\n      )\r\n      await destination.run(hastTree, file)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @type {TransformMutate}\r\n   */\r\n  return function (tree, file) {\r\n    // Cast because root in -> root out.\r\n    return /** @type {HastRoot} */ (\r\n      toHast(tree, {file, ...(options || destination)})\r\n    )\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,MAAM,QAAO,oBAAoB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,YAAYA,CAACC,WAAW,EAAEC,OAAO,EAAE;EACzD,IAAID,WAAW,IAAI,KAAK,IAAIA,WAAW,EAAE;IACvC;AACJ;AACA;IACI,OAAO,gBAAgBE,IAAI,EAAEC,IAAI,EAAE;MACjC;MACA,MAAMC,QAAQ,GAAG;MACfN,MAAM,CAACI,IAAI,EAAE;QAACC,IAAI;QAAE,GAAGF;MAAO,CAAC,CAChC;MACD,MAAMD,WAAW,CAACK,GAAG,CAACD,QAAQ,EAAED,IAAI,CAAC;IACvC,CAAC;EACH;;EAEA;AACF;AACA;EACE,OAAO,UAAUD,IAAI,EAAEC,IAAI,EAAE;IAC3B;IACA,OAAO,uBACLL,MAAM,CAACI,IAAI,EAAE;MAACC,IAAI;MAAE,IAAIF,OAAO,IAAID,WAAW;IAAC,CAAC,CAAC;EAErD,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}