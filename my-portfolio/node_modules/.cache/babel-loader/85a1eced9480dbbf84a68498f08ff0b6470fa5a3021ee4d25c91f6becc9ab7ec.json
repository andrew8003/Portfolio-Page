{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Chunk} Chunk\r\n * @typedef {import('micromark-util-types').Code} Code\r\n * @typedef {import('micromark-util-types').Encoding} Encoding\r\n * @typedef {import('micromark-util-types').Value} Value\r\n */\n\n/**\r\n * @callback Preprocessor\r\n * @param {Value} value\r\n * @param {Encoding | null | undefined} [encoding]\r\n * @param {boolean | null | undefined} [end=false]\r\n * @returns {Array<Chunk>}\r\n */\n\nimport { codes, constants } from 'micromark-util-symbol';\nconst search = /[\\0\\t\\n\\r]/g;\n\n/**\r\n * @returns {Preprocessor}\r\n */\nexport function preprocess() {\n  let column = 1;\n  let buffer = '';\n  /** @type {boolean | undefined} */\n  let start = true;\n  /** @type {boolean | undefined} */\n  let atCarriageReturn;\n  return preprocessor;\n\n  /** @type {Preprocessor} */\n  // eslint-disable-next-line complexity\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = [];\n    /** @type {RegExpMatchArray | null} */\n    let match;\n    /** @type {number} */\n    let next;\n    /** @type {number} */\n    let startPosition;\n    /** @type {number} */\n    let endPosition;\n    /** @type {Code} */\n    let code;\n    value = buffer + (typeof value === 'string' ? value.toString() : new TextDecoder(encoding || undefined).decode(value));\n    startPosition = 0;\n    buffer = '';\n    if (start) {\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\n      if (value.charCodeAt(0) === codes.byteOrderMarker) {\n        startPosition++;\n      }\n      start = undefined;\n    }\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition;\n      match = search.exec(value);\n      endPosition = match && match.index !== undefined ? match.index : value.length;\n      code = value.charCodeAt(endPosition);\n      if (!match) {\n        buffer = value.slice(startPosition);\n        break;\n      }\n      if (code === codes.lf && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(codes.carriageReturnLineFeed);\n        atCarriageReturn = undefined;\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(codes.carriageReturn);\n          atCarriageReturn = undefined;\n        }\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition));\n          column += endPosition - startPosition;\n        }\n        switch (code) {\n          case codes.nul:\n            {\n              chunks.push(codes.replacementCharacter);\n              column++;\n              break;\n            }\n          case codes.ht:\n            {\n              next = Math.ceil(column / constants.tabSize) * constants.tabSize;\n              chunks.push(codes.horizontalTab);\n              while (column++ < next) chunks.push(codes.virtualSpace);\n              break;\n            }\n          case codes.lf:\n            {\n              chunks.push(codes.lineFeed);\n              column = 1;\n              break;\n            }\n          default:\n            {\n              atCarriageReturn = true;\n              column = 1;\n            }\n        }\n      }\n      startPosition = endPosition + 1;\n    }\n    if (end) {\n      if (atCarriageReturn) chunks.push(codes.carriageReturn);\n      if (buffer) chunks.push(buffer);\n      chunks.push(codes.eof);\n    }\n    return chunks;\n  }\n}","map":{"version":3,"names":["codes","constants","search","preprocess","column","buffer","start","atCarriageReturn","preprocessor","value","encoding","end","chunks","match","next","startPosition","endPosition","code","toString","TextDecoder","undefined","decode","charCodeAt","byteOrderMarker","length","lastIndex","exec","index","slice","lf","push","carriageReturnLineFeed","carriageReturn","nul","replacementCharacter","ht","Math","ceil","tabSize","horizontalTab","virtualSpace","lineFeed","eof"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/micromark/dev/lib/preprocess.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Chunk} Chunk\r\n * @typedef {import('micromark-util-types').Code} Code\r\n * @typedef {import('micromark-util-types').Encoding} Encoding\r\n * @typedef {import('micromark-util-types').Value} Value\r\n */\r\n\r\n/**\r\n * @callback Preprocessor\r\n * @param {Value} value\r\n * @param {Encoding | null | undefined} [encoding]\r\n * @param {boolean | null | undefined} [end=false]\r\n * @returns {Array<Chunk>}\r\n */\r\n\r\nimport {codes, constants} from 'micromark-util-symbol'\r\n\r\nconst search = /[\\0\\t\\n\\r]/g\r\n\r\n/**\r\n * @returns {Preprocessor}\r\n */\r\nexport function preprocess() {\r\n  let column = 1\r\n  let buffer = ''\r\n  /** @type {boolean | undefined} */\r\n  let start = true\r\n  /** @type {boolean | undefined} */\r\n  let atCarriageReturn\r\n\r\n  return preprocessor\r\n\r\n  /** @type {Preprocessor} */\r\n  // eslint-disable-next-line complexity\r\n  function preprocessor(value, encoding, end) {\r\n    /** @type {Array<Chunk>} */\r\n    const chunks = []\r\n    /** @type {RegExpMatchArray | null} */\r\n    let match\r\n    /** @type {number} */\r\n    let next\r\n    /** @type {number} */\r\n    let startPosition\r\n    /** @type {number} */\r\n    let endPosition\r\n    /** @type {Code} */\r\n    let code\r\n\r\n    value =\r\n      buffer +\r\n      (typeof value === 'string'\r\n        ? value.toString()\r\n        : new TextDecoder(encoding || undefined).decode(value))\r\n\r\n    startPosition = 0\r\n    buffer = ''\r\n\r\n    if (start) {\r\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\r\n      if (value.charCodeAt(0) === codes.byteOrderMarker) {\r\n        startPosition++\r\n      }\r\n\r\n      start = undefined\r\n    }\r\n\r\n    while (startPosition < value.length) {\r\n      search.lastIndex = startPosition\r\n      match = search.exec(value)\r\n      endPosition =\r\n        match && match.index !== undefined ? match.index : value.length\r\n      code = value.charCodeAt(endPosition)\r\n\r\n      if (!match) {\r\n        buffer = value.slice(startPosition)\r\n        break\r\n      }\r\n\r\n      if (\r\n        code === codes.lf &&\r\n        startPosition === endPosition &&\r\n        atCarriageReturn\r\n      ) {\r\n        chunks.push(codes.carriageReturnLineFeed)\r\n        atCarriageReturn = undefined\r\n      } else {\r\n        if (atCarriageReturn) {\r\n          chunks.push(codes.carriageReturn)\r\n          atCarriageReturn = undefined\r\n        }\r\n\r\n        if (startPosition < endPosition) {\r\n          chunks.push(value.slice(startPosition, endPosition))\r\n          column += endPosition - startPosition\r\n        }\r\n\r\n        switch (code) {\r\n          case codes.nul: {\r\n            chunks.push(codes.replacementCharacter)\r\n            column++\r\n\r\n            break\r\n          }\r\n\r\n          case codes.ht: {\r\n            next = Math.ceil(column / constants.tabSize) * constants.tabSize\r\n            chunks.push(codes.horizontalTab)\r\n            while (column++ < next) chunks.push(codes.virtualSpace)\r\n\r\n            break\r\n          }\r\n\r\n          case codes.lf: {\r\n            chunks.push(codes.lineFeed)\r\n            column = 1\r\n\r\n            break\r\n          }\r\n\r\n          default: {\r\n            atCarriageReturn = true\r\n            column = 1\r\n          }\r\n        }\r\n      }\r\n\r\n      startPosition = endPosition + 1\r\n    }\r\n\r\n    if (end) {\r\n      if (atCarriageReturn) chunks.push(codes.carriageReturn)\r\n      if (buffer) chunks.push(buffer)\r\n      chunks.push(codes.eof)\r\n    }\r\n\r\n    return chunks\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}