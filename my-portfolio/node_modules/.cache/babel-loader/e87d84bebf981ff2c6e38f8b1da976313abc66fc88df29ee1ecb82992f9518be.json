{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Code} Code\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this;\n  /** @type {Construct} */\n  const closeStart = {\n    tokenize: tokenizeCloseStart,\n    partial: true\n  };\n  let initialPrefix = 0;\n  let sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n\n  /**\r\n   * Start of code.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *     ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    // To do: parse whitespace like `markdown-rs`.\n    return beforeSequenceOpen(code);\n  }\n\n  /**\r\n   * In opening fence, after prefix, at sequence.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *     ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function beforeSequenceOpen(code) {\n    const tail = self.events[self.events.length - 1];\n    initialPrefix = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n    marker = code;\n    effects.enter(\"codeFenced\");\n    effects.enter(\"codeFencedFence\");\n    effects.enter(\"codeFencedFenceSequence\");\n    return sequenceOpen(code);\n  }\n\n  /**\r\n   * In opening fence sequence.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *      ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      sizeOpen++;\n      effects.consume(code);\n      return sequenceOpen;\n    }\n    if (sizeOpen < 3) {\n      return nok(code);\n    }\n    effects.exit(\"codeFencedFenceSequence\");\n    return markdownSpace(code) ? factorySpace(effects, infoBefore, \"whitespace\")(code) : infoBefore(code);\n  }\n\n  /**\r\n   * In opening fence, after the sequence (and optional whitespace), before info.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *        ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function infoBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"codeFencedFence\");\n      return self.interrupt ? ok(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n    }\n    effects.enter(\"codeFencedFenceInfo\");\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return info(code);\n  }\n\n  /**\r\n   * In info.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *        ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function info(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit(\"codeFencedFenceInfo\");\n      return infoBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit(\"codeFencedFenceInfo\");\n      return factorySpace(effects, metaBefore, \"whitespace\")(code);\n    }\n    if (code === 96 && code === marker) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return info;\n  }\n\n  /**\r\n   * In opening fence, after info and whitespace, before meta.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js eval\r\n   *           ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return infoBefore(code);\n    }\n    effects.enter(\"codeFencedFenceMeta\");\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return meta(code);\n  }\n\n  /**\r\n   * In meta.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js eval\r\n   *           ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit(\"codeFencedFenceMeta\");\n      return infoBefore(code);\n    }\n    if (code === 96 && code === marker) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\r\n   * At eol/eof in code, before a non-lazy closing fence or content.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *          ^\r\n   * > | alert(1)\r\n   *             ^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function atNonLazyBreak(code) {\n    return effects.attempt(closeStart, after, contentBefore)(code);\n  }\n\n  /**\r\n   * Before code content, not a closing fence, at eol.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   * > | alert(1)\r\n   *             ^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function contentBefore(code) {\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return contentStart;\n  }\n\n  /**\r\n   * Before code content, not a closing fence.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   * > | alert(1)\r\n   *     ^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function contentStart(code) {\n    return initialPrefix > 0 && markdownSpace(code) ? factorySpace(effects, beforeContentChunk, \"linePrefix\", initialPrefix + 1)(code) : beforeContentChunk(code);\n  }\n\n  /**\r\n   * Before code content, after optional prefix.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   * > | alert(1)\r\n   *     ^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function beforeContentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n    }\n    effects.enter(\"codeFlowValue\");\n    return contentChunk(code);\n  }\n\n  /**\r\n   * In code content.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   * > | alert(1)\r\n   *     ^^^^^^^^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"codeFlowValue\");\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\r\n   * After code.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   *   | alert(1)\r\n   * > | ~~~\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function after(code) {\n    effects.exit(\"codeFenced\");\n    return ok(code);\n  }\n\n  /**\r\n   * @this {TokenizeContext}\r\n   * @type {Tokenizer}\r\n   */\n  function tokenizeCloseStart(effects, ok, nok) {\n    let size = 0;\n    return startBefore;\n\n    /**\r\n     *\r\n     *\r\n     * @type {State}\r\n     */\n    function startBefore(code) {\n      effects.enter(\"lineEnding\");\n      effects.consume(code);\n      effects.exit(\"lineEnding\");\n      return start;\n    }\n\n    /**\r\n     * Before closing fence, at optional whitespace.\r\n     *\r\n     * ```markdown\r\n     *   | ~~~js\r\n     *   | alert(1)\r\n     * > | ~~~\r\n     *     ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\n    function start(code) {\n      // Always populated by defaults.\n\n      // To do: `enter` here or in next state?\n      effects.enter(\"codeFencedFence\");\n      return markdownSpace(code) ? factorySpace(effects, beforeSequenceClose, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code) : beforeSequenceClose(code);\n    }\n\n    /**\r\n     * In closing fence, after optional whitespace, at sequence.\r\n     *\r\n     * ```markdown\r\n     *   | ~~~js\r\n     *   | alert(1)\r\n     * > | ~~~\r\n     *     ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\n    function beforeSequenceClose(code) {\n      if (code === marker) {\n        effects.enter(\"codeFencedFenceSequence\");\n        return sequenceClose(code);\n      }\n      return nok(code);\n    }\n\n    /**\r\n     * In closing fence sequence.\r\n     *\r\n     * ```markdown\r\n     *   | ~~~js\r\n     *   | alert(1)\r\n     * > | ~~~\r\n     *     ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\n    function sequenceClose(code) {\n      if (code === marker) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size >= sizeOpen) {\n        effects.exit(\"codeFencedFenceSequence\");\n        return markdownSpace(code) ? factorySpace(effects, sequenceCloseAfter, \"whitespace\")(code) : sequenceCloseAfter(code);\n      }\n      return nok(code);\n    }\n\n    /**\r\n     * After closing fence sequence, after optional whitespace.\r\n     *\r\n     * ```markdown\r\n     *   | ~~~js\r\n     *   | alert(1)\r\n     * > | ~~~\r\n     *        ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\n    function sequenceCloseAfter(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit(\"codeFencedFence\");\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /**\r\n   *\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    if (code === null) {\n      return nok(code);\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineStart;\n  }\n\n  /**\r\n   *\r\n   *\r\n   * @type {State}\r\n   */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","markdownSpace","nonLazyContinuation","tokenize","tokenizeNonLazyContinuation","partial","codeFenced","name","tokenizeCodeFenced","concrete","effects","ok","nok","self","closeStart","tokenizeCloseStart","initialPrefix","sizeOpen","marker","start","code","beforeSequenceOpen","tail","events","length","type","sliceSerialize","enter","sequenceOpen","consume","exit","infoBefore","interrupt","check","atNonLazyBreak","after","contentType","info","metaBefore","meta","attempt","contentBefore","contentStart","beforeContentChunk","contentChunk","size","startBefore","beforeSequenceClose","parser","constructs","disable","null","includes","undefined","sequenceClose","sequenceCloseAfter","lineStart","lazy","now","line"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/micromark-core-commonmark/lib/code-fenced.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Code} Code\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n */\r\n\r\nimport { factorySpace } from 'micromark-factory-space';\r\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\r\n/** @type {Construct} */\r\nconst nonLazyContinuation = {\r\n  tokenize: tokenizeNonLazyContinuation,\r\n  partial: true\r\n};\r\n\r\n/** @type {Construct} */\r\nexport const codeFenced = {\r\n  name: 'codeFenced',\r\n  tokenize: tokenizeCodeFenced,\r\n  concrete: true\r\n};\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeCodeFenced(effects, ok, nok) {\r\n  const self = this;\r\n  /** @type {Construct} */\r\n  const closeStart = {\r\n    tokenize: tokenizeCloseStart,\r\n    partial: true\r\n  };\r\n  let initialPrefix = 0;\r\n  let sizeOpen = 0;\r\n  /** @type {NonNullable<Code>} */\r\n  let marker;\r\n  return start;\r\n\r\n  /**\r\n   * Start of code.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *     ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    // To do: parse whitespace like `markdown-rs`.\r\n    return beforeSequenceOpen(code);\r\n  }\r\n\r\n  /**\r\n   * In opening fence, after prefix, at sequence.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *     ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function beforeSequenceOpen(code) {\r\n    const tail = self.events[self.events.length - 1];\r\n    initialPrefix = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\r\n    marker = code;\r\n    effects.enter(\"codeFenced\");\r\n    effects.enter(\"codeFencedFence\");\r\n    effects.enter(\"codeFencedFenceSequence\");\r\n    return sequenceOpen(code);\r\n  }\r\n\r\n  /**\r\n   * In opening fence sequence.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *      ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function sequenceOpen(code) {\r\n    if (code === marker) {\r\n      sizeOpen++;\r\n      effects.consume(code);\r\n      return sequenceOpen;\r\n    }\r\n    if (sizeOpen < 3) {\r\n      return nok(code);\r\n    }\r\n    effects.exit(\"codeFencedFenceSequence\");\r\n    return markdownSpace(code) ? factorySpace(effects, infoBefore, \"whitespace\")(code) : infoBefore(code);\r\n  }\r\n\r\n  /**\r\n   * In opening fence, after the sequence (and optional whitespace), before info.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *        ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function infoBefore(code) {\r\n    if (code === null || markdownLineEnding(code)) {\r\n      effects.exit(\"codeFencedFence\");\r\n      return self.interrupt ? ok(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\r\n    }\r\n    effects.enter(\"codeFencedFenceInfo\");\r\n    effects.enter(\"chunkString\", {\r\n      contentType: \"string\"\r\n    });\r\n    return info(code);\r\n  }\r\n\r\n  /**\r\n   * In info.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *        ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function info(code) {\r\n    if (code === null || markdownLineEnding(code)) {\r\n      effects.exit(\"chunkString\");\r\n      effects.exit(\"codeFencedFenceInfo\");\r\n      return infoBefore(code);\r\n    }\r\n    if (markdownSpace(code)) {\r\n      effects.exit(\"chunkString\");\r\n      effects.exit(\"codeFencedFenceInfo\");\r\n      return factorySpace(effects, metaBefore, \"whitespace\")(code);\r\n    }\r\n    if (code === 96 && code === marker) {\r\n      return nok(code);\r\n    }\r\n    effects.consume(code);\r\n    return info;\r\n  }\r\n\r\n  /**\r\n   * In opening fence, after info and whitespace, before meta.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js eval\r\n   *           ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function metaBefore(code) {\r\n    if (code === null || markdownLineEnding(code)) {\r\n      return infoBefore(code);\r\n    }\r\n    effects.enter(\"codeFencedFenceMeta\");\r\n    effects.enter(\"chunkString\", {\r\n      contentType: \"string\"\r\n    });\r\n    return meta(code);\r\n  }\r\n\r\n  /**\r\n   * In meta.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js eval\r\n   *           ^\r\n   *   | alert(1)\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function meta(code) {\r\n    if (code === null || markdownLineEnding(code)) {\r\n      effects.exit(\"chunkString\");\r\n      effects.exit(\"codeFencedFenceMeta\");\r\n      return infoBefore(code);\r\n    }\r\n    if (code === 96 && code === marker) {\r\n      return nok(code);\r\n    }\r\n    effects.consume(code);\r\n    return meta;\r\n  }\r\n\r\n  /**\r\n   * At eol/eof in code, before a non-lazy closing fence or content.\r\n   *\r\n   * ```markdown\r\n   * > | ~~~js\r\n   *          ^\r\n   * > | alert(1)\r\n   *             ^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function atNonLazyBreak(code) {\r\n    return effects.attempt(closeStart, after, contentBefore)(code);\r\n  }\r\n\r\n  /**\r\n   * Before code content, not a closing fence, at eol.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   * > | alert(1)\r\n   *             ^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function contentBefore(code) {\r\n    effects.enter(\"lineEnding\");\r\n    effects.consume(code);\r\n    effects.exit(\"lineEnding\");\r\n    return contentStart;\r\n  }\r\n\r\n  /**\r\n   * Before code content, not a closing fence.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   * > | alert(1)\r\n   *     ^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function contentStart(code) {\r\n    return initialPrefix > 0 && markdownSpace(code) ? factorySpace(effects, beforeContentChunk, \"linePrefix\", initialPrefix + 1)(code) : beforeContentChunk(code);\r\n  }\r\n\r\n  /**\r\n   * Before code content, after optional prefix.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   * > | alert(1)\r\n   *     ^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function beforeContentChunk(code) {\r\n    if (code === null || markdownLineEnding(code)) {\r\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\r\n    }\r\n    effects.enter(\"codeFlowValue\");\r\n    return contentChunk(code);\r\n  }\r\n\r\n  /**\r\n   * In code content.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   * > | alert(1)\r\n   *     ^^^^^^^^\r\n   *   | ~~~\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function contentChunk(code) {\r\n    if (code === null || markdownLineEnding(code)) {\r\n      effects.exit(\"codeFlowValue\");\r\n      return beforeContentChunk(code);\r\n    }\r\n    effects.consume(code);\r\n    return contentChunk;\r\n  }\r\n\r\n  /**\r\n   * After code.\r\n   *\r\n   * ```markdown\r\n   *   | ~~~js\r\n   *   | alert(1)\r\n   * > | ~~~\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function after(code) {\r\n    effects.exit(\"codeFenced\");\r\n    return ok(code);\r\n  }\r\n\r\n  /**\r\n   * @this {TokenizeContext}\r\n   * @type {Tokenizer}\r\n   */\r\n  function tokenizeCloseStart(effects, ok, nok) {\r\n    let size = 0;\r\n    return startBefore;\r\n\r\n    /**\r\n     *\r\n     *\r\n     * @type {State}\r\n     */\r\n    function startBefore(code) {\r\n      effects.enter(\"lineEnding\");\r\n      effects.consume(code);\r\n      effects.exit(\"lineEnding\");\r\n      return start;\r\n    }\r\n\r\n    /**\r\n     * Before closing fence, at optional whitespace.\r\n     *\r\n     * ```markdown\r\n     *   | ~~~js\r\n     *   | alert(1)\r\n     * > | ~~~\r\n     *     ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function start(code) {\r\n      // Always populated by defaults.\r\n\r\n      // To do: `enter` here or in next state?\r\n      effects.enter(\"codeFencedFence\");\r\n      return markdownSpace(code) ? factorySpace(effects, beforeSequenceClose, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code) : beforeSequenceClose(code);\r\n    }\r\n\r\n    /**\r\n     * In closing fence, after optional whitespace, at sequence.\r\n     *\r\n     * ```markdown\r\n     *   | ~~~js\r\n     *   | alert(1)\r\n     * > | ~~~\r\n     *     ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function beforeSequenceClose(code) {\r\n      if (code === marker) {\r\n        effects.enter(\"codeFencedFenceSequence\");\r\n        return sequenceClose(code);\r\n      }\r\n      return nok(code);\r\n    }\r\n\r\n    /**\r\n     * In closing fence sequence.\r\n     *\r\n     * ```markdown\r\n     *   | ~~~js\r\n     *   | alert(1)\r\n     * > | ~~~\r\n     *     ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function sequenceClose(code) {\r\n      if (code === marker) {\r\n        size++;\r\n        effects.consume(code);\r\n        return sequenceClose;\r\n      }\r\n      if (size >= sizeOpen) {\r\n        effects.exit(\"codeFencedFenceSequence\");\r\n        return markdownSpace(code) ? factorySpace(effects, sequenceCloseAfter, \"whitespace\")(code) : sequenceCloseAfter(code);\r\n      }\r\n      return nok(code);\r\n    }\r\n\r\n    /**\r\n     * After closing fence sequence, after optional whitespace.\r\n     *\r\n     * ```markdown\r\n     *   | ~~~js\r\n     *   | alert(1)\r\n     * > | ~~~\r\n     *        ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function sequenceCloseAfter(code) {\r\n      if (code === null || markdownLineEnding(code)) {\r\n        effects.exit(\"codeFencedFence\");\r\n        return ok(code);\r\n      }\r\n      return nok(code);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\r\n  const self = this;\r\n  return start;\r\n\r\n  /**\r\n   *\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    if (code === null) {\r\n      return nok(code);\r\n    }\r\n    effects.enter(\"lineEnding\");\r\n    effects.consume(code);\r\n    effects.exit(\"lineEnding\");\r\n    return lineStart;\r\n  }\r\n\r\n  /**\r\n   *\r\n   *\r\n   * @type {State}\r\n   */\r\n  function lineStart(code) {\r\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}