{"ast":null,"code":"/**\r\n * @typedef {import('hast').Element} HastElement\r\n * @typedef {import('hast').ElementContent} HastElementContent\r\n * @typedef {import('hast').Nodes} HastNodes\r\n * @typedef {import('hast').Properties} HastProperties\r\n * @typedef {import('hast').RootContent} HastRootContent\r\n * @typedef {import('hast').Text} HastText\r\n *\r\n * @typedef {import('mdast').Definition} MdastDefinition\r\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\r\n * @typedef {import('mdast').Nodes} MdastNodes\r\n * @typedef {import('mdast').Parents} MdastParents\r\n *\r\n * @typedef {import('vfile').VFile} VFile\r\n *\r\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\r\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\r\n */\n\n/**\r\n * @callback Handler\r\n *   Handle a node.\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {any} node\r\n *   mdast node to handle.\r\n * @param {MdastParents | undefined} parent\r\n *   Parent of `node`.\r\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\r\n *   hast node.\r\n *\r\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\r\n *   Handle nodes.\r\n *\r\n * @typedef Options\r\n *   Configuration (optional).\r\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\r\n *   Whether to persist raw HTML in markdown in the hast tree (default:\r\n *   `false`).\r\n * @property {string | null | undefined} [clobberPrefix='user-content-']\r\n *   Prefix to use before the `id` property on footnotes to prevent them from\r\n *   *clobbering* (default: `'user-content-'`).\r\n *\r\n *   Pass `''` for trusted markdown and when you are careful with\r\n *   polyfilling.\r\n *   You could pass a different prefix.\r\n *\r\n *   DOM clobbering is this:\r\n *\r\n *   ```html\r\n *   <p id=\"x\"></p>\r\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\r\n *   ```\r\n *\r\n *   The above example shows that elements are made available by browsers, by\r\n *   their ID, on the `window` object.\r\n *   This is a security risk because you might be expecting some other variable\r\n *   at that place.\r\n *   It can also break polyfills.\r\n *   Using a prefix solves these problems.\r\n * @property {VFile | null | undefined} [file]\r\n *   Corresponding virtual file representing the input document (optional).\r\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\r\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\r\n *\r\n *   The default value is:\r\n *\r\n *   ```js\r\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\r\n *     const result = [{type: 'text', value: '↩'}]\r\n *\r\n *     if (rereferenceIndex > 1) {\r\n *       result.push({\r\n *         type: 'element',\r\n *         tagName: 'sup',\r\n *         properties: {},\r\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\r\n *       })\r\n *     }\r\n *\r\n *     return result\r\n *   }\r\n *   ```\r\n *\r\n *   This content is used in the `a` element of each backreference (the `↩`\r\n *   links).\r\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\r\n *   Label to describe the backreference back to references (default:\r\n *   `defaultFootnoteBackLabel`).\r\n *\r\n *   The default value is:\r\n *\r\n *   ```js\r\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\r\n *    return (\r\n *      'Back to reference ' +\r\n *      (referenceIndex + 1) +\r\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\r\n *    )\r\n *   }\r\n *   ```\r\n *\r\n *   Change it when the markdown is not in English.\r\n *\r\n *   This label is used in the `ariaLabel` property on each backreference\r\n *   (the `↩` links).\r\n *   It affects users of assistive technology.\r\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\r\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\r\n *\r\n *   Change it when the markdown is not in English.\r\n *\r\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\r\n *   is defined that does that) and so affects screen readers only.\r\n *   If you do have such a class, but want to show this section to everyone,\r\n *   pass different properties with the `footnoteLabelProperties` option.\r\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\r\n *   Properties to use on the footnote label (default: `{className:\r\n *   ['sr-only']}`).\r\n *\r\n *   Change it to show the label and add other properties.\r\n *\r\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\r\n *   is defined that does that) and so affects screen readers only.\r\n *   If you do have such a class, but want to show this section to everyone,\r\n *   pass an empty string.\r\n *   You can also add different properties.\r\n *\r\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\r\n *   > calls use it with `aria-describedby` to provide an accessible label.\r\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\r\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\r\n *\r\n *   Change it to match your document structure.\r\n *\r\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\r\n *   is defined that does that) and so affects screen readers only.\r\n *   If you do have such a class, but want to show this section to everyone,\r\n *   pass different properties with the `footnoteLabelProperties` option.\r\n * @property {Handlers | null | undefined} [handlers]\r\n *   Extra handlers for nodes (optional).\r\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\r\n *   List of custom mdast node types to pass through (keep) in hast (note that\r\n *   the node itself is passed, but eventual children are transformed)\r\n *   (optional).\r\n * @property {Handler | null | undefined} [unknownHandler]\r\n *   Handler for all unknown nodes (optional).\r\n *\r\n * @typedef State\r\n *   Info passed around.\r\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\r\n *   Transform the children of an mdast parent to hast.\r\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\r\n *   Honor the `data` of `from`, and generate an element instead of `node`.\r\n * @property {Map<string, MdastDefinition>} definitionById\r\n *   Definitions by their identifier.\r\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\r\n *   Footnote definitions by their identifier.\r\n * @property {Map<string, number>} footnoteCounts\r\n *   Counts for how often the same footnote was called.\r\n * @property {Array<string>} footnoteOrder\r\n *   Identifiers of order when footnote calls first appear in tree order.\r\n * @property {Handlers} handlers\r\n *   Applied handlers.\r\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\r\n *   Transform an mdast node to hast.\r\n * @property {Options} options\r\n *   Configuration.\r\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\r\n *   Copy a node’s positional info.\r\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\r\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\r\n */\n\nimport structuredClone from '@ungap/structured-clone';\nimport { visit } from 'unist-util-visit';\nimport { position } from 'unist-util-position';\nimport { handlers as defaultHandlers } from './handlers/index.js';\nconst own = {}.hasOwnProperty;\n\n/** @type {Options} */\nconst emptyOptions = {};\n\n/**\r\n * Create `state` from an mdast tree.\r\n *\r\n * @param {MdastNodes} tree\r\n *   mdast node to transform.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {State}\r\n *   `state` function.\r\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions;\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map();\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map();\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map();\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {\n    ...defaultHandlers,\n    ...settings.handlers\n  };\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  };\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById;\n      const id = String(node.identifier).toUpperCase();\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node);\n      }\n    }\n  });\n  return state;\n\n  /**\r\n   * Transform an mdast node into a hast node.\r\n   *\r\n   * @param {MdastNodes} node\r\n   *   mdast node.\r\n   * @param {MdastParents | undefined} [parent]\r\n   *   Parent of `node`.\r\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\r\n   *   Resulting hast node.\r\n   */\n  function one(node, parent) {\n    const type = node.type;\n    const handle = state.handlers[type];\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent);\n    }\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {\n          children,\n          ...shallow\n        } = node;\n        const result = structuredClone(shallow);\n        // @ts-expect-error: TS doesn’t understand…\n        result.children = state.all(node);\n        // @ts-expect-error: TS doesn’t understand…\n        return result;\n      }\n\n      // @ts-expect-error: it’s custom.\n      return structuredClone(node);\n    }\n    const unknown = state.options.unknownHandler || defaultUnknownHandler;\n    return unknown(state, node, parent);\n  }\n\n  /**\r\n   * Transform the children of an mdast node into hast nodes.\r\n   *\r\n   * @param {MdastNodes} parent\r\n   *   mdast node to compile\r\n   * @returns {Array<HastElementContent>}\r\n   *   Resulting hast nodes.\r\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = [];\n    if ('children' in parent) {\n      const nodes = parent.children;\n      let index = -1;\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent);\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value);\n            }\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0];\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value);\n              }\n            }\n          }\n          if (Array.isArray(result)) {\n            values.push(...result);\n          } else {\n            values.push(result);\n          }\n        }\n      }\n    }\n    return values;\n  }\n}\n\n/**\r\n * Copy a node’s positional info.\r\n *\r\n * @param {MdastNodes} from\r\n *   mdast node to copy from.\r\n * @param {HastNodes} to\r\n *   hast node to copy into.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from);\n}\n\n/**\r\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\r\n *\r\n * @template {HastNodes} Type\r\n *   Node type.\r\n * @param {MdastNodes} from\r\n *   mdast node to use data from.\r\n * @param {Type} to\r\n *   hast node to change.\r\n * @returns {HastElement | Type}\r\n *   Nothing.\r\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to;\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName;\n    const hChildren = from.data.hChildren;\n    const hProperties = from.data.hProperties;\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName;\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result];\n        result = {\n          type: 'element',\n          tagName: hName,\n          properties: {},\n          children\n        };\n      }\n    }\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties));\n    }\n    if ('children' in result && result.children && hChildren !== null && hChildren !== undefined) {\n      result.children = hChildren;\n    }\n  }\n  return result;\n}\n\n/**\r\n * Transform an unknown node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdastNodes} node\r\n *   Unknown mdast node.\r\n * @returns {HastElement | HastText}\r\n *   Resulting hast node.\r\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {};\n  /** @type {HastElement | HastText} */\n  const result = 'value' in node && !(own.call(data, 'hProperties') || own.call(data, 'hChildren')) ? {\n    type: 'text',\n    value: node.value\n  } : {\n    type: 'element',\n    tagName: 'div',\n    properties: {},\n    children: state.all(node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n\n/**\r\n * Wrap `nodes` with line endings between each node.\r\n *\r\n * @template {HastRootContent} Type\r\n *   Node type.\r\n * @param {Array<Type>} nodes\r\n *   List of nodes to wrap.\r\n * @param {boolean | undefined} [loose=false]\r\n *   Whether to add line endings at start and end (default: `false`).\r\n * @returns {Array<HastText | Type>}\r\n *   Wrapped nodes.\r\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = [];\n  let index = -1;\n  if (loose) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n  while (++index < nodes.length) {\n    if (index) result.push({\n      type: 'text',\n      value: '\\n'\n    });\n    result.push(nodes[index]);\n  }\n  if (loose && nodes.length > 0) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n  return result;\n}\n\n/**\r\n * Trim spaces and tabs at the start of `value`.\r\n *\r\n * @param {string} value\r\n *   Value to trim.\r\n * @returns {string}\r\n *   Result.\r\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0;\n  let code = value.charCodeAt(index);\n  while (code === 9 || code === 32) {\n    index++;\n    code = value.charCodeAt(index);\n  }\n  return value.slice(index);\n}","map":{"version":3,"names":["structuredClone","visit","position","handlers","defaultHandlers","own","hasOwnProperty","emptyOptions","createState","tree","options","settings","definitionById","Map","footnoteById","footnoteCounts","state","all","applyData","footnoteOrder","one","patch","wrap","node","type","map","id","String","identifier","toUpperCase","has","set","parent","handle","call","passThrough","includes","children","shallow","result","unknown","unknownHandler","defaultUnknownHandler","values","nodes","index","length","Array","isArray","value","trimMarkdownSpaceStart","head","push","from","to","data","hName","hChildren","hProperties","tagName","properties","Object","assign","undefined","loose","code","charCodeAt","slice"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/mdast-util-to-hast/lib/state.js"],"sourcesContent":["/**\r\n * @typedef {import('hast').Element} HastElement\r\n * @typedef {import('hast').ElementContent} HastElementContent\r\n * @typedef {import('hast').Nodes} HastNodes\r\n * @typedef {import('hast').Properties} HastProperties\r\n * @typedef {import('hast').RootContent} HastRootContent\r\n * @typedef {import('hast').Text} HastText\r\n *\r\n * @typedef {import('mdast').Definition} MdastDefinition\r\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\r\n * @typedef {import('mdast').Nodes} MdastNodes\r\n * @typedef {import('mdast').Parents} MdastParents\r\n *\r\n * @typedef {import('vfile').VFile} VFile\r\n *\r\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\r\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\r\n */\r\n\r\n/**\r\n * @callback Handler\r\n *   Handle a node.\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {any} node\r\n *   mdast node to handle.\r\n * @param {MdastParents | undefined} parent\r\n *   Parent of `node`.\r\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\r\n *   hast node.\r\n *\r\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\r\n *   Handle nodes.\r\n *\r\n * @typedef Options\r\n *   Configuration (optional).\r\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\r\n *   Whether to persist raw HTML in markdown in the hast tree (default:\r\n *   `false`).\r\n * @property {string | null | undefined} [clobberPrefix='user-content-']\r\n *   Prefix to use before the `id` property on footnotes to prevent them from\r\n *   *clobbering* (default: `'user-content-'`).\r\n *\r\n *   Pass `''` for trusted markdown and when you are careful with\r\n *   polyfilling.\r\n *   You could pass a different prefix.\r\n *\r\n *   DOM clobbering is this:\r\n *\r\n *   ```html\r\n *   <p id=\"x\"></p>\r\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\r\n *   ```\r\n *\r\n *   The above example shows that elements are made available by browsers, by\r\n *   their ID, on the `window` object.\r\n *   This is a security risk because you might be expecting some other variable\r\n *   at that place.\r\n *   It can also break polyfills.\r\n *   Using a prefix solves these problems.\r\n * @property {VFile | null | undefined} [file]\r\n *   Corresponding virtual file representing the input document (optional).\r\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\r\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\r\n *\r\n *   The default value is:\r\n *\r\n *   ```js\r\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\r\n *     const result = [{type: 'text', value: '↩'}]\r\n *\r\n *     if (rereferenceIndex > 1) {\r\n *       result.push({\r\n *         type: 'element',\r\n *         tagName: 'sup',\r\n *         properties: {},\r\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\r\n *       })\r\n *     }\r\n *\r\n *     return result\r\n *   }\r\n *   ```\r\n *\r\n *   This content is used in the `a` element of each backreference (the `↩`\r\n *   links).\r\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\r\n *   Label to describe the backreference back to references (default:\r\n *   `defaultFootnoteBackLabel`).\r\n *\r\n *   The default value is:\r\n *\r\n *   ```js\r\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\r\n *    return (\r\n *      'Back to reference ' +\r\n *      (referenceIndex + 1) +\r\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\r\n *    )\r\n *   }\r\n *   ```\r\n *\r\n *   Change it when the markdown is not in English.\r\n *\r\n *   This label is used in the `ariaLabel` property on each backreference\r\n *   (the `↩` links).\r\n *   It affects users of assistive technology.\r\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\r\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\r\n *\r\n *   Change it when the markdown is not in English.\r\n *\r\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\r\n *   is defined that does that) and so affects screen readers only.\r\n *   If you do have such a class, but want to show this section to everyone,\r\n *   pass different properties with the `footnoteLabelProperties` option.\r\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\r\n *   Properties to use on the footnote label (default: `{className:\r\n *   ['sr-only']}`).\r\n *\r\n *   Change it to show the label and add other properties.\r\n *\r\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\r\n *   is defined that does that) and so affects screen readers only.\r\n *   If you do have such a class, but want to show this section to everyone,\r\n *   pass an empty string.\r\n *   You can also add different properties.\r\n *\r\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\r\n *   > calls use it with `aria-describedby` to provide an accessible label.\r\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\r\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\r\n *\r\n *   Change it to match your document structure.\r\n *\r\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\r\n *   is defined that does that) and so affects screen readers only.\r\n *   If you do have such a class, but want to show this section to everyone,\r\n *   pass different properties with the `footnoteLabelProperties` option.\r\n * @property {Handlers | null | undefined} [handlers]\r\n *   Extra handlers for nodes (optional).\r\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\r\n *   List of custom mdast node types to pass through (keep) in hast (note that\r\n *   the node itself is passed, but eventual children are transformed)\r\n *   (optional).\r\n * @property {Handler | null | undefined} [unknownHandler]\r\n *   Handler for all unknown nodes (optional).\r\n *\r\n * @typedef State\r\n *   Info passed around.\r\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\r\n *   Transform the children of an mdast parent to hast.\r\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\r\n *   Honor the `data` of `from`, and generate an element instead of `node`.\r\n * @property {Map<string, MdastDefinition>} definitionById\r\n *   Definitions by their identifier.\r\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\r\n *   Footnote definitions by their identifier.\r\n * @property {Map<string, number>} footnoteCounts\r\n *   Counts for how often the same footnote was called.\r\n * @property {Array<string>} footnoteOrder\r\n *   Identifiers of order when footnote calls first appear in tree order.\r\n * @property {Handlers} handlers\r\n *   Applied handlers.\r\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\r\n *   Transform an mdast node to hast.\r\n * @property {Options} options\r\n *   Configuration.\r\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\r\n *   Copy a node’s positional info.\r\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\r\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\r\n */\r\n\r\nimport structuredClone from '@ungap/structured-clone'\r\nimport {visit} from 'unist-util-visit'\r\nimport {position} from 'unist-util-position'\r\nimport {handlers as defaultHandlers} from './handlers/index.js'\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/** @type {Options} */\r\nconst emptyOptions = {}\r\n\r\n/**\r\n * Create `state` from an mdast tree.\r\n *\r\n * @param {MdastNodes} tree\r\n *   mdast node to transform.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {State}\r\n *   `state` function.\r\n */\r\nexport function createState(tree, options) {\r\n  const settings = options || emptyOptions\r\n  /** @type {Map<string, MdastDefinition>} */\r\n  const definitionById = new Map()\r\n  /** @type {Map<string, MdastFootnoteDefinition>} */\r\n  const footnoteById = new Map()\r\n  /** @type {Map<string, number>} */\r\n  const footnoteCounts = new Map()\r\n  /** @type {Handlers} */\r\n  // @ts-expect-error: the root handler returns a root.\r\n  // Hard to type.\r\n  const handlers = {...defaultHandlers, ...settings.handlers}\r\n\r\n  /** @type {State} */\r\n  const state = {\r\n    all,\r\n    applyData,\r\n    definitionById,\r\n    footnoteById,\r\n    footnoteCounts,\r\n    footnoteOrder: [],\r\n    handlers,\r\n    one,\r\n    options: settings,\r\n    patch,\r\n    wrap\r\n  }\r\n\r\n  visit(tree, function (node) {\r\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\r\n      const map = node.type === 'definition' ? definitionById : footnoteById\r\n      const id = String(node.identifier).toUpperCase()\r\n\r\n      // Mimick CM behavior of link definitions.\r\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\r\n      if (!map.has(id)) {\r\n        // @ts-expect-error: node type matches map.\r\n        map.set(id, node)\r\n      }\r\n    }\r\n  })\r\n\r\n  return state\r\n\r\n  /**\r\n   * Transform an mdast node into a hast node.\r\n   *\r\n   * @param {MdastNodes} node\r\n   *   mdast node.\r\n   * @param {MdastParents | undefined} [parent]\r\n   *   Parent of `node`.\r\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\r\n   *   Resulting hast node.\r\n   */\r\n  function one(node, parent) {\r\n    const type = node.type\r\n    const handle = state.handlers[type]\r\n\r\n    if (own.call(state.handlers, type) && handle) {\r\n      return handle(state, node, parent)\r\n    }\r\n\r\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\r\n      if ('children' in node) {\r\n        const {children, ...shallow} = node\r\n        const result = structuredClone(shallow)\r\n        // @ts-expect-error: TS doesn’t understand…\r\n        result.children = state.all(node)\r\n        // @ts-expect-error: TS doesn’t understand…\r\n        return result\r\n      }\r\n\r\n      // @ts-expect-error: it’s custom.\r\n      return structuredClone(node)\r\n    }\r\n\r\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\r\n\r\n    return unknown(state, node, parent)\r\n  }\r\n\r\n  /**\r\n   * Transform the children of an mdast node into hast nodes.\r\n   *\r\n   * @param {MdastNodes} parent\r\n   *   mdast node to compile\r\n   * @returns {Array<HastElementContent>}\r\n   *   Resulting hast nodes.\r\n   */\r\n  function all(parent) {\r\n    /** @type {Array<HastElementContent>} */\r\n    const values = []\r\n\r\n    if ('children' in parent) {\r\n      const nodes = parent.children\r\n      let index = -1\r\n      while (++index < nodes.length) {\r\n        const result = state.one(nodes[index], parent)\r\n\r\n        // To do: see if we van clean this? Can we merge texts?\r\n        if (result) {\r\n          if (index && nodes[index - 1].type === 'break') {\r\n            if (!Array.isArray(result) && result.type === 'text') {\r\n              result.value = trimMarkdownSpaceStart(result.value)\r\n            }\r\n\r\n            if (!Array.isArray(result) && result.type === 'element') {\r\n              const head = result.children[0]\r\n\r\n              if (head && head.type === 'text') {\r\n                head.value = trimMarkdownSpaceStart(head.value)\r\n              }\r\n            }\r\n          }\r\n\r\n          if (Array.isArray(result)) {\r\n            values.push(...result)\r\n          } else {\r\n            values.push(result)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return values\r\n  }\r\n}\r\n\r\n/**\r\n * Copy a node’s positional info.\r\n *\r\n * @param {MdastNodes} from\r\n *   mdast node to copy from.\r\n * @param {HastNodes} to\r\n *   hast node to copy into.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction patch(from, to) {\r\n  if (from.position) to.position = position(from)\r\n}\r\n\r\n/**\r\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\r\n *\r\n * @template {HastNodes} Type\r\n *   Node type.\r\n * @param {MdastNodes} from\r\n *   mdast node to use data from.\r\n * @param {Type} to\r\n *   hast node to change.\r\n * @returns {HastElement | Type}\r\n *   Nothing.\r\n */\r\nfunction applyData(from, to) {\r\n  /** @type {HastElement | Type} */\r\n  let result = to\r\n\r\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\r\n  if (from && from.data) {\r\n    const hName = from.data.hName\r\n    const hChildren = from.data.hChildren\r\n    const hProperties = from.data.hProperties\r\n\r\n    if (typeof hName === 'string') {\r\n      // Transforming the node resulted in an element with a different name\r\n      // than wanted:\r\n      if (result.type === 'element') {\r\n        result.tagName = hName\r\n      }\r\n      // Transforming the node resulted in a non-element, which happens for\r\n      // raw, text, and root nodes (unless custom handlers are passed).\r\n      // The intent of `hName` is to create an element, but likely also to keep\r\n      // the content around (otherwise: pass `hChildren`).\r\n      else {\r\n        /** @type {Array<HastElementContent>} */\r\n        // @ts-expect-error: assume no doctypes in `root`.\r\n        const children = 'children' in result ? result.children : [result]\r\n        result = {type: 'element', tagName: hName, properties: {}, children}\r\n      }\r\n    }\r\n\r\n    if (result.type === 'element' && hProperties) {\r\n      Object.assign(result.properties, structuredClone(hProperties))\r\n    }\r\n\r\n    if (\r\n      'children' in result &&\r\n      result.children &&\r\n      hChildren !== null &&\r\n      hChildren !== undefined\r\n    ) {\r\n      result.children = hChildren\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Transform an unknown node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdastNodes} node\r\n *   Unknown mdast node.\r\n * @returns {HastElement | HastText}\r\n *   Resulting hast node.\r\n */\r\nfunction defaultUnknownHandler(state, node) {\r\n  const data = node.data || {}\r\n  /** @type {HastElement | HastText} */\r\n  const result =\r\n    'value' in node &&\r\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\r\n      ? {type: 'text', value: node.value}\r\n      : {\r\n          type: 'element',\r\n          tagName: 'div',\r\n          properties: {},\r\n          children: state.all(node)\r\n        }\r\n\r\n  state.patch(node, result)\r\n  return state.applyData(node, result)\r\n}\r\n\r\n/**\r\n * Wrap `nodes` with line endings between each node.\r\n *\r\n * @template {HastRootContent} Type\r\n *   Node type.\r\n * @param {Array<Type>} nodes\r\n *   List of nodes to wrap.\r\n * @param {boolean | undefined} [loose=false]\r\n *   Whether to add line endings at start and end (default: `false`).\r\n * @returns {Array<HastText | Type>}\r\n *   Wrapped nodes.\r\n */\r\nexport function wrap(nodes, loose) {\r\n  /** @type {Array<HastText | Type>} */\r\n  const result = []\r\n  let index = -1\r\n\r\n  if (loose) {\r\n    result.push({type: 'text', value: '\\n'})\r\n  }\r\n\r\n  while (++index < nodes.length) {\r\n    if (index) result.push({type: 'text', value: '\\n'})\r\n    result.push(nodes[index])\r\n  }\r\n\r\n  if (loose && nodes.length > 0) {\r\n    result.push({type: 'text', value: '\\n'})\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Trim spaces and tabs at the start of `value`.\r\n *\r\n * @param {string} value\r\n *   Value to trim.\r\n * @returns {string}\r\n *   Result.\r\n */\r\nfunction trimMarkdownSpaceStart(value) {\r\n  let index = 0\r\n  let code = value.charCodeAt(index)\r\n\r\n  while (code === 9 || code === 32) {\r\n    index++\r\n    code = value.charCodeAt(index)\r\n  }\r\n\r\n  return value.slice(index)\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,eAAe,MAAM,yBAAyB;AACrD,SAAQC,KAAK,QAAO,kBAAkB;AACtC,SAAQC,QAAQ,QAAO,qBAAqB;AAC5C,SAAQC,QAAQ,IAAIC,eAAe,QAAO,qBAAqB;AAE/D,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA,MAAMC,YAAY,GAAG,CAAC,CAAC;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,IAAI,EAAEC,OAAO,EAAE;EACzC,MAAMC,QAAQ,GAAGD,OAAO,IA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}