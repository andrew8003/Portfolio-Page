{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Encoding} Encoding\r\n * @typedef {import('micromark-util-types').Options} Options\r\n * @typedef {import('micromark-util-types').Value} Value\r\n */\n\nimport { compile } from './lib/compile.js';\nimport { parse } from './lib/parse.js';\nimport { postprocess } from './lib/postprocess.js';\nimport { preprocess } from './lib/preprocess.js';\nexport { compile } from './lib/compile.js';\nexport { parse } from './lib/parse.js';\nexport { postprocess } from './lib/postprocess.js';\nexport { preprocess } from './lib/preprocess.js';\n\n/**\r\n * Compile markdown to HTML.\r\n *\r\n * > Note: which encodings are supported depends on the engine.\r\n * > For info on Node.js, see:\r\n * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.\r\n *\r\n * @overload\r\n * @param {Value} value\r\n *   Markdown to parse (`string` or `Uint8Array`).\r\n * @param {Encoding | null | undefined} encoding\r\n *   Character encoding to understand `value` as when it’s a `Uint8Array`\r\n *   (`string`, default: `'utf8'`).\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {string}\r\n *   Compiled HTML.\r\n *\r\n * @overload\r\n * @param {Value} value\r\n *   Markdown to parse (`string` or `Uint8Array`).\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {string}\r\n *   Compiled HTML.\r\n *\r\n * @param {Value} value\r\n *   Markdown to parse (`string` or `Uint8Array`).\r\n * @param {Encoding | Options | null | undefined} [encoding]\r\n *   Character encoding to understand `value` as when it’s a `Uint8Array`\r\n *   (`string`, default: `'utf8'`).\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {string}\r\n *   Compiled HTML.\r\n */\nexport function micromark(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n  return compile(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n}","map":{"version":3,"names":["compile","parse","postprocess","preprocess","micromark","value","encoding","options","undefined","document","write"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/micromark/dev/index.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Encoding} Encoding\r\n * @typedef {import('micromark-util-types').Options} Options\r\n * @typedef {import('micromark-util-types').Value} Value\r\n */\r\n\r\nimport {compile} from './lib/compile.js'\r\nimport {parse} from './lib/parse.js'\r\nimport {postprocess} from './lib/postprocess.js'\r\nimport {preprocess} from './lib/preprocess.js'\r\n\r\nexport {compile} from './lib/compile.js'\r\nexport {parse} from './lib/parse.js'\r\nexport {postprocess} from './lib/postprocess.js'\r\nexport {preprocess} from './lib/preprocess.js'\r\n\r\n/**\r\n * Compile markdown to HTML.\r\n *\r\n * > Note: which encodings are supported depends on the engine.\r\n * > For info on Node.js, see:\r\n * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.\r\n *\r\n * @overload\r\n * @param {Value} value\r\n *   Markdown to parse (`string` or `Uint8Array`).\r\n * @param {Encoding | null | undefined} encoding\r\n *   Character encoding to understand `value` as when it’s a `Uint8Array`\r\n *   (`string`, default: `'utf8'`).\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {string}\r\n *   Compiled HTML.\r\n *\r\n * @overload\r\n * @param {Value} value\r\n *   Markdown to parse (`string` or `Uint8Array`).\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {string}\r\n *   Compiled HTML.\r\n *\r\n * @param {Value} value\r\n *   Markdown to parse (`string` or `Uint8Array`).\r\n * @param {Encoding | Options | null | undefined} [encoding]\r\n *   Character encoding to understand `value` as when it’s a `Uint8Array`\r\n *   (`string`, default: `'utf8'`).\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {string}\r\n *   Compiled HTML.\r\n */\r\nexport function micromark(value, encoding, options) {\r\n  if (typeof encoding !== 'string') {\r\n    options = encoding\r\n    encoding = undefined\r\n  }\r\n\r\n  return compile(options)(\r\n    postprocess(\r\n      parse(options).document().write(preprocess()(value, encoding, true))\r\n    )\r\n  )\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,OAAO,QAAO,kBAAkB;AACxC,SAAQC,KAAK,QAAO,gBAAgB;AACpC,SAAQC,WAAW,QAAO,sBAAsB;AAChD,SAAQC,UAAU,QAAO,qBAAqB;AAE9C,SAAQH,OAAO,QAAO,kBAAkB;AACxC,SAAQC,KAAK,QAAO,gBAAgB;AACpC,SAAQC,WAAW,QAAO,sBAAsB;AAChD,SAAQC,UAAU,QAAO,qBAAqB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EAClD,IAAI,OAAOD,QAAQ,KAAK,QAAQ,EAAE;IAChCC,OAAO,GAAGD,QAAQ;IAClBA,QAAQ,GAAGE,SAAS;EACtB;EAEA,OAAOR,OAAO,CAACO,OAAO,CAAC,CACrBL,WAAW,CACTD,KAAK,CAACM,OAAO,CAAC,CAACE,QAAQ,CAAC,CAAC,CAACC,KAAK,CAACP,UAAU,CAAC,CAAC,CAACE,KAAK,EAAEC,QAAQ,EAAE,IAAI,CAAC,CACrE,CACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}