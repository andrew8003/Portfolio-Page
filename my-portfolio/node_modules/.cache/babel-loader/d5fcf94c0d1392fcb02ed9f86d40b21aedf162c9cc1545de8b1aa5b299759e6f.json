{"ast":null,"code":"/// <reference lib=\"dom\" />\n\n/* eslint-env browser */\n\nconst element = document.createElement('i');\n\n/**\r\n * @param {string} value\r\n * @returns {string|false}\r\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';';\n  element.innerHTML = characterReference;\n  const char = element.textContent;\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\n    return false;\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return char === characterReference ? false : char;\n}","map":{"version":3,"names":["element","document","createElement","decodeNamedCharacterReference","value","characterReference","innerHTML","char","textContent","charCodeAt","length"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/decode-named-character-reference/index.dom.js"],"sourcesContent":["/// <reference lib=\"dom\" />\r\n\r\n/* eslint-env browser */\r\n\r\nconst element = document.createElement('i')\r\n\r\n/**\r\n * @param {string} value\r\n * @returns {string|false}\r\n */\r\nexport function decodeNamedCharacterReference(value) {\r\n  const characterReference = '&' + value + ';'\r\n  element.innerHTML = characterReference\r\n  const char = element.textContent\r\n\r\n  // Some named character references do not require the closing semicolon\r\n  // (`&not`, for instance), which leads to situations where parsing the assumed\r\n  // named reference of `&notit;` will result in the string `¬it;`.\r\n  // When we encounter a trailing semicolon after parsing, and the character\r\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\r\n  // matching was not complete.\r\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\r\n  // yield `null`.\r\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\r\n    return false\r\n  }\r\n\r\n  // If the decoded string is equal to the input, the character reference was\r\n  // not valid.\r\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\r\n  // yield `null`.\r\n  return char === characterReference ? false : char\r\n}\r\n"],"mappings":"AAAA;;AAEA;;AAEA,MAAMA,OAAO,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;;AAE3C;AACA;AACA;AACA;AACA,OAAO,SAASC,6BAA6BA,CAACC,KAAK,EAAE;EACnD,MAAMC,kBAAkB,GAAG,GAAG,GAAGD,KAAK,GAAG,GAAG;EAC5CJ,OAAO,CAACM,SAAS,GAAGD,kBAAkB;EACtC,MAAME,IAAI,GAAGP,OAAO,CAACQ,WAAW;;EAEhC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAID,IAAI,CAACE,UAAU,CAACF,IAAI,CAACG,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,aAAaN,KAAK,KAAK,MAAM,EAAE;IACzE,OAAO,KAAK;EACd;;EAEA;EACA;EACA;EACA;EACA,OAAOG,IAAI,KAAKF,kBAAkB,GAAG,KAAK,GAAGE,IAAI;AACnD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}