{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Previous} Previous\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n */\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n};\n\n// To do: next major: don’t resolve, like `markdown-rs`.\n/** @type {Resolver} */\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === \"codeTextData\") {\n        // Then we have padding.\n        events[headEnterIndex][1].type = \"codeTextPadding\";\n        events[tailExitIndex][1].type = \"codeTextPadding\";\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = \"codeTextData\";\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Previous}\r\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 96 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}\n\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this;\n  let sizeOpen = 0;\n  /** @type {number} */\n  let size;\n  /** @type {Token} */\n  let token;\n  return start;\n\n  /**\r\n   * Start of code (text).\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *     ^\r\n   * > | \\`a`\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    effects.enter(\"codeText\");\n    effects.enter(\"codeTextSequence\");\n    return sequenceOpen(code);\n  }\n\n  /**\r\n   * In opening sequence.\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function sequenceOpen(code) {\n    if (code === 96) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    effects.exit(\"codeTextSequence\");\n    return between(code);\n  }\n\n  /**\r\n   * Between something and something else.\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *      ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function between(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code);\n    }\n\n    // To do: next major: don’t do spaces in resolve, but when compiling,\n    // like `markdown-rs`.\n    // Tabs don’t work, and virtual spaces don’t make sense.\n    if (code === 32) {\n      effects.enter('space');\n      effects.consume(code);\n      effects.exit('space');\n      return between;\n    }\n\n    // Closing fence? Could also be data.\n    if (code === 96) {\n      token = effects.enter(\"codeTextSequence\");\n      size = 0;\n      return sequenceClose(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter(\"lineEnding\");\n      effects.consume(code);\n      effects.exit(\"lineEnding\");\n      return between;\n    }\n\n    // Data.\n    effects.enter(\"codeTextData\");\n    return data(code);\n  }\n\n  /**\r\n   * In data.\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function data(code) {\n    if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {\n      effects.exit(\"codeTextData\");\n      return between(code);\n    }\n    effects.consume(code);\n    return data;\n  }\n\n  /**\r\n   * In closing sequence.\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function sequenceClose(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code);\n      size++;\n      return sequenceClose;\n    }\n\n    // Done!\n    if (size === sizeOpen) {\n      effects.exit(\"codeTextSequence\");\n      effects.exit(\"codeText\");\n      return ok(code);\n    }\n\n    // More or less accents: mark as data.\n    token.type = \"codeTextData\";\n    return data(code);\n  }\n}","map":{"version":3,"names":["markdownLineEnding","codeText","name","tokenize","tokenizeCodeText","resolve","resolveCodeText","previous","events","tailExitIndex","length","headEnterIndex","index","enter","type","undefined","end","splice","code","effects","ok","nok","self","sizeOpen","size","token","start","sequenceOpen","consume","exit","between","sequenceClose","data"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/micromark-core-commonmark/lib/code-text.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Previous} Previous\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n */\r\n\r\nimport { markdownLineEnding } from 'micromark-util-character';\r\n/** @type {Construct} */\r\nexport const codeText = {\r\n  name: 'codeText',\r\n  tokenize: tokenizeCodeText,\r\n  resolve: resolveCodeText,\r\n  previous\r\n};\r\n\r\n// To do: next major: don’t resolve, like `markdown-rs`.\r\n/** @type {Resolver} */\r\nfunction resolveCodeText(events) {\r\n  let tailExitIndex = events.length - 4;\r\n  let headEnterIndex = 3;\r\n  /** @type {number} */\r\n  let index;\r\n  /** @type {number | undefined} */\r\n  let enter;\r\n\r\n  // If we start and end with an EOL or a space.\r\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\r\n    index = headEnterIndex;\r\n\r\n    // And we have data.\r\n    while (++index < tailExitIndex) {\r\n      if (events[index][1].type === \"codeTextData\") {\r\n        // Then we have padding.\r\n        events[headEnterIndex][1].type = \"codeTextPadding\";\r\n        events[tailExitIndex][1].type = \"codeTextPadding\";\r\n        headEnterIndex += 2;\r\n        tailExitIndex -= 2;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Merge adjacent spaces and data.\r\n  index = headEnterIndex - 1;\r\n  tailExitIndex++;\r\n  while (++index <= tailExitIndex) {\r\n    if (enter === undefined) {\r\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\r\n        enter = index;\r\n      }\r\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\r\n      events[enter][1].type = \"codeTextData\";\r\n      if (index !== enter + 2) {\r\n        events[enter][1].end = events[index - 1][1].end;\r\n        events.splice(enter + 2, index - enter - 2);\r\n        tailExitIndex -= index - enter - 2;\r\n        index = enter + 2;\r\n      }\r\n      enter = undefined;\r\n    }\r\n  }\r\n  return events;\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Previous}\r\n */\r\nfunction previous(code) {\r\n  // If there is a previous code, there will always be a tail.\r\n  return code !== 96 || this.events[this.events.length - 1][1].type === \"characterEscape\";\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeCodeText(effects, ok, nok) {\r\n  const self = this;\r\n  let sizeOpen = 0;\r\n  /** @type {number} */\r\n  let size;\r\n  /** @type {Token} */\r\n  let token;\r\n  return start;\r\n\r\n  /**\r\n   * Start of code (text).\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *     ^\r\n   * > | \\`a`\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    effects.enter(\"codeText\");\r\n    effects.enter(\"codeTextSequence\");\r\n    return sequenceOpen(code);\r\n  }\r\n\r\n  /**\r\n   * In opening sequence.\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function sequenceOpen(code) {\r\n    if (code === 96) {\r\n      effects.consume(code);\r\n      sizeOpen++;\r\n      return sequenceOpen;\r\n    }\r\n    effects.exit(\"codeTextSequence\");\r\n    return between(code);\r\n  }\r\n\r\n  /**\r\n   * Between something and something else.\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *      ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function between(code) {\r\n    // EOF.\r\n    if (code === null) {\r\n      return nok(code);\r\n    }\r\n\r\n    // To do: next major: don’t do spaces in resolve, but when compiling,\r\n    // like `markdown-rs`.\r\n    // Tabs don’t work, and virtual spaces don’t make sense.\r\n    if (code === 32) {\r\n      effects.enter('space');\r\n      effects.consume(code);\r\n      effects.exit('space');\r\n      return between;\r\n    }\r\n\r\n    // Closing fence? Could also be data.\r\n    if (code === 96) {\r\n      token = effects.enter(\"codeTextSequence\");\r\n      size = 0;\r\n      return sequenceClose(code);\r\n    }\r\n    if (markdownLineEnding(code)) {\r\n      effects.enter(\"lineEnding\");\r\n      effects.consume(code);\r\n      effects.exit(\"lineEnding\");\r\n      return between;\r\n    }\r\n\r\n    // Data.\r\n    effects.enter(\"codeTextData\");\r\n    return data(code);\r\n  }\r\n\r\n  /**\r\n   * In data.\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function data(code) {\r\n    if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {\r\n      effects.exit(\"codeTextData\");\r\n      return between(code);\r\n    }\r\n    effects.consume(code);\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * In closing sequence.\r\n   *\r\n   * ```markdown\r\n   * > | `a`\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function sequenceClose(code) {\r\n    // More.\r\n    if (code === 96) {\r\n      effects.consume(code);\r\n      size++;\r\n      return sequenceClose;\r\n    }\r\n\r\n    // Done!\r\n    if (size === sizeOpen) {\r\n      effects.exit(\"codeTextSequence\");\r\n      effects.exit(\"codeText\");\r\n      return ok(code);\r\n    }\r\n\r\n    // More or less accents: mark as data.\r\n    token.type = \"codeTextData\";\r\n    return data(code);\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}