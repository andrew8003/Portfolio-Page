{"ast":null,"code":"/**\r\n * @typedef {import('mdast').Break} Break\r\n * @typedef {import('mdast').Blockquote} Blockquote\r\n * @typedef {import('mdast').Code} Code\r\n * @typedef {import('mdast').Definition} Definition\r\n * @typedef {import('mdast').Emphasis} Emphasis\r\n * @typedef {import('mdast').Heading} Heading\r\n * @typedef {import('mdast').Html} Html\r\n * @typedef {import('mdast').Image} Image\r\n * @typedef {import('mdast').InlineCode} InlineCode\r\n * @typedef {import('mdast').Link} Link\r\n * @typedef {import('mdast').List} List\r\n * @typedef {import('mdast').ListItem} ListItem\r\n * @typedef {import('mdast').Nodes} Nodes\r\n * @typedef {import('mdast').Paragraph} Paragraph\r\n * @typedef {import('mdast').Parent} Parent\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('mdast').ReferenceType} ReferenceType\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast').Strong} Strong\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\r\n *\r\n * @typedef {import('micromark-util-types').Encoding} Encoding\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Value} Value\r\n *\r\n * @typedef {import('unist').Point} Point\r\n *\r\n * @typedef {import('../index.js').CompileData} CompileData\r\n */\n\n/**\r\n * @typedef {Omit<Parent, 'children' | 'type'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\r\n */\n\n/**\r\n * @callback Transform\r\n *   Extra transform, to change the AST afterwards.\r\n * @param {Root} tree\r\n *   Tree to transform.\r\n * @returns {Root | null | undefined | void}\r\n *   New tree or nothing (in which case the current tree is used).\r\n *\r\n * @callback Handle\r\n *   Handle a token.\r\n * @param {CompileContext} this\r\n *   Context.\r\n * @param {Token} token\r\n *   Current token.\r\n * @returns {undefined | void}\r\n *   Nothing.\r\n *\r\n * @typedef {Record<string, Handle>} Handles\r\n *   Token types mapping to handles\r\n *\r\n * @callback OnEnterError\r\n *   Handle the case where the `right` token is open, but it is closed (by the\r\n *   `left` token) or because we reached the end of the document.\r\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\r\n *   Context.\r\n * @param {Token | undefined} left\r\n *   Left token.\r\n * @param {Token} right\r\n *   Right token.\r\n * @returns {undefined}\r\n *   Nothing.\r\n *\r\n * @callback OnExitError\r\n *   Handle the case where the `right` token is open but it is closed by\r\n *   exiting the `left` token.\r\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\r\n *   Context.\r\n * @param {Token} left\r\n *   Left token.\r\n * @param {Token} right\r\n *   Right token.\r\n * @returns {undefined}\r\n *   Nothing.\r\n *\r\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\r\n *   Open token on the stack, with an optional error handler for when\r\n *   that token isn’t closed properly.\r\n */\n\n/**\r\n * @typedef Config\r\n *   Configuration.\r\n *\r\n *   We have our defaults, but extensions will add more.\r\n * @property {Array<string>} canContainEols\r\n *   Token types where line endings are used.\r\n * @property {Handles} enter\r\n *   Opening handles.\r\n * @property {Handles} exit\r\n *   Closing handles.\r\n * @property {Array<Transform>} transforms\r\n *   Tree transforms.\r\n *\r\n * @typedef {Partial<Config>} Extension\r\n *   Change how markdown tokens from micromark are turned into mdast.\r\n *\r\n * @typedef CompileContext\r\n *   mdast compiler context.\r\n * @property {Array<Fragment | Nodes>} stack\r\n *   Stack of nodes.\r\n * @property {Array<TokenTuple>} tokenStack\r\n *   Stack of tokens.\r\n * @property {(this: CompileContext) => undefined} buffer\r\n *   Capture some of the output data.\r\n * @property {(this: CompileContext) => string} resume\r\n *   Stop capturing and access the output data.\r\n * @property {(this: CompileContext, node: Nodes, token: Token, onError?: OnEnterError) => undefined} enter\r\n *   Enter a node.\r\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => undefined} exit\r\n *   Exit a node.\r\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\r\n *   Get the string value of a token.\r\n * @property {Config} config\r\n *   Configuration.\r\n * @property {CompileData} data\r\n *   Info passed around; key/value store.\r\n *\r\n * @typedef FromMarkdownOptions\r\n *   Configuration for how to build mdast.\r\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\r\n *   Extensions for this utility to change how tokens are turned into a tree.\r\n *\r\n * @typedef {ParseOptions & FromMarkdownOptions} Options\r\n *   Configuration.\r\n */\n\nimport { toString } from 'mdast-util-to-string';\nimport { parse, postprocess, preprocess } from 'micromark';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { decodeString } from 'micromark-util-decode-string';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { stringifyPosition } from 'unist-util-stringify-position';\nconst own = {}.hasOwnProperty;\n\n/**\r\n * Turn markdown into a syntax tree.\r\n *\r\n * @overload\r\n * @param {Value} value\r\n * @param {Encoding | null | undefined} [encoding]\r\n * @param {Options | null | undefined} [options]\r\n * @returns {Root}\r\n *\r\n * @overload\r\n * @param {Value} value\r\n * @param {Options | null | undefined} [options]\r\n * @returns {Root}\r\n *\r\n * @param {Value} value\r\n *   Markdown to parse.\r\n * @param {Encoding | Options | null | undefined} [encoding]\r\n *   Character encoding for when `value` is `Buffer`.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {Root}\r\n *   mdast tree.\r\n */\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n}\n\n/**\r\n * Note this compiler only understand complete buffering, not streaming.\r\n *\r\n * @param {Options | null | undefined} [options]\r\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      characterReference: onexitcharacterreference,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  };\n  configure(config, (options || {}).mdastExtensions || []);\n\n  /** @type {CompileData} */\n  const data = {};\n  return compile;\n\n  /**\r\n   * Turn micromark events into an mdast tree.\r\n   *\r\n   * @param {Array<Event>} events\r\n   *   Events.\r\n   * @returns {Root}\r\n   *   mdast tree.\r\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    };\n    /** @type {Array<number>} */\n    const listStack = [];\n    let index = -1;\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === \"listOrdered\" || events[index][1].type === \"listUnordered\") {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          const tail = listStack.pop();\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      const handler = config[events[index][0]];\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1];\n      const handler = tail[1] || defaultOnError;\n      handler.call(context, undefined, tail[0]);\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    };\n\n    // Call transforms.\n    index = -1;\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n    return tree;\n  }\n\n  /**\r\n   * @param {Array<Event>} events\r\n   * @param {number} start\r\n   * @param {number} length\r\n   * @returns {number}\r\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1;\n    let containerBalance = -1;\n    let listSpread = false;\n    /** @type {Token | undefined} */\n    let listItem;\n    /** @type {number | undefined} */\n    let lineIndex;\n    /** @type {number | undefined} */\n    let firstBlankLineIndex;\n    /** @type {boolean | undefined} */\n    let atMarker;\n    while (++index <= length) {\n      const event = events[index];\n      switch (event[1].type) {\n        case \"listUnordered\":\n        case \"listOrdered\":\n        case \"blockQuote\":\n          {\n            if (event[0] === 'enter') {\n              containerBalance++;\n            } else {\n              containerBalance--;\n            }\n            atMarker = undefined;\n            break;\n          }\n        case \"lineEndingBlank\":\n          {\n            if (event[0] === 'enter') {\n              if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                firstBlankLineIndex = index;\n              }\n              atMarker = undefined;\n            }\n            break;\n          }\n        case \"linePrefix\":\n        case \"listItemValue\":\n        case \"listItemMarker\":\n        case \"listItemPrefix\":\n        case \"listItemPrefixWhitespace\":\n          {\n            // Empty.\n\n            break;\n          }\n        default:\n          {\n            atMarker = undefined;\n          }\n      }\n      if (!containerBalance && event[0] === 'enter' && event[1].type === \"listItemPrefix\" || containerBalance === -1 && event[0] === 'exit' && (event[1].type === \"listUnordered\" || event[1].type === \"listOrdered\")) {\n        if (listItem) {\n          let tailIndex = index;\n          lineIndex = undefined;\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex];\n            if (tailEvent[1].type === \"lineEnding\" || tailEvent[1].type === \"lineEndingBlank\") {\n              if (tailEvent[0] === 'exit') continue;\n              if (lineIndex) {\n                events[lineIndex][1].type = \"lineEndingBlank\";\n                listSpread = true;\n              }\n              tailEvent[1].type = \"lineEnding\";\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === \"linePrefix\" || tailEvent[1].type === \"blockQuotePrefix\" || tailEvent[1].type === \"blockQuotePrefixWhitespace\" || tailEvent[1].type === \"blockQuoteMarker\" || tailEvent[1].type === \"listItemIndent\") {\n              // Empty\n            } else {\n              break;\n            }\n          }\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            listItem._spread = true;\n          }\n\n          // Fix position.\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        }\n\n        // Create a new list item.\n        if (event[1].type === \"listItemPrefix\") {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          };\n          listItem = item;\n          events.splice(index, 0, ['enter', item, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    }\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n\n  /**\r\n   * Create an opener handle.\r\n   *\r\n   * @param {(token: Token) => Nodes} create\r\n   *   Create a node.\r\n   * @param {Handle | undefined} [and]\r\n   *   Optional function to also run.\r\n   * @returns {Handle}\r\n   *   Handle.\r\n   */\n  function opener(create, and) {\n    return open;\n\n    /**\r\n     * @this {CompileContext}\r\n     * @param {Token} token\r\n     * @returns {undefined}\r\n     */\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @returns {undefined}\r\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   *   Context.\r\n   * @param {Nodes} node\r\n   *   Node to enter.\r\n   * @param {Token} token\r\n   *   Corresponding token.\r\n   * @param {OnEnterError | undefined} [errorHandler]\r\n   *   Handle the case where this token is open, but it is closed by something else.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1];\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children;\n    siblings.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler]);\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    };\n  }\n\n  /**\r\n   * Create a closer handle.\r\n   *\r\n   * @param {Handle | undefined} [and]\r\n   *   Optional function to also run.\r\n   * @returns {Handle}\r\n   *   Handle.\r\n   */\n  function closer(and) {\n    return close;\n\n    /**\r\n     * @this {CompileContext}\r\n     * @param {Token} token\r\n     * @returns {undefined}\r\n     */\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   *   Context.\r\n   * @param {Token} token\r\n   *   Corresponding token.\r\n   * @param {OnExitError | undefined} [onExitError]\r\n   *   Handle the case where another token is open.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop();\n    const open = this.tokenStack.pop();\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): it’s not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        const handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n    node.position.end = point(token.end);\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @returns {string}\r\n   */\n  function resume() {\n    return toString(this.stack.pop());\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2];\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n      this.data.expectingFirstListItemValue = undefined;\n    }\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.lang = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return;\n    this.buffer();\n    this.data.flowCodeInside = true;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitcodefenced() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    this.data.flowCodeInside = undefined;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitcodeindented() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length;\n      node.depth = depth;\n    }\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    node.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1];\n    /** @type {Array<Nodes>} */\n    const siblings = node.children;\n    let tail = siblings[siblings.length - 1];\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text();\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: we’ll add `end` later.\n        end: undefined\n      };\n      siblings.push(tail);\n    }\n    this.stack.push(tail);\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop();\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1];\n    // If we’re at a hard break, include the line ending in there.\n    if (this.data.atHardBreak) {\n      const tail = context.children[context.children.length - 1];\n      tail.position.end = point(token.end);\n      this.data.atHardBreak = undefined;\n      return;\n    }\n    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexithtmltext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitcodetext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1];\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference';\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType;\n      // @ts-expect-error: mutate.\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier;\n      // @ts-expect-error: mutate.\n      delete node.label;\n    }\n    this.data.referenceType = undefined;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1];\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference';\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType;\n      // @ts-expect-error: mutate.\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier;\n      // @ts-expect-error: mutate.\n      delete node.label;\n    }\n    this.data.referenceType = undefined;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token);\n    const ancestor = this.stack[this.stack.length - 2];\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string);\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1];\n    const value = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    // Assume a reference.\n    this.data.inReference = true;\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children;\n      node.children = children;\n    } else {\n      node.alt = value;\n    }\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitresource() {\n    this.data.inReference = undefined;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed';\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label;\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    this.data.referenceType = 'full';\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    this.data.characterReferenceType = token.type;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token);\n    const type = this.data.characterReferenceType;\n    /** @type {string} */\n    let value;\n    if (type) {\n      value = decodeNumericCharacterReference(data, type === \"characterReferenceMarkerNumeric\" ? 10 : 16);\n      this.data.characterReferenceType = undefined;\n    } else {\n      const result = decodeNamedCharacterReference(data);\n      value = result;\n    }\n    const tail = this.stack[this.stack.length - 1];\n    tail.value += value;\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitcharacterreference(token) {\n    const tail = this.stack.pop();\n    tail.position.end = point(token.end);\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = this.sliceSerialize(token);\n  }\n\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    };\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n\n  /** @returns {Html} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n\n  /**\r\n   * @param {Token} token\r\n   * @returns {List}\r\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    };\n  }\n\n  /**\r\n   * @param {Token} token\r\n   * @returns {ListItem}\r\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n\n/**\r\n * Copy a point-like value.\r\n *\r\n * @param {Point} d\r\n *   Point-like value.\r\n * @returns {Point}\r\n *   unist point.\r\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  };\n}\n\n/**\r\n * @param {Config} combined\r\n * @param {Array<Array<Extension> | Extension>} extensions\r\n * @returns {undefined}\r\n */\nfunction configure(combined, extensions) {\n  let index = -1;\n  while (++index < extensions.length) {\n    const value = extensions[index];\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n}\n\n/**\r\n * @param {Config} combined\r\n * @param {Extension} extension\r\n * @returns {undefined}\r\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key;\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols':\n          {\n            const right = extension[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n        case 'transforms':\n          {\n            const right = extension[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n        case 'enter':\n        case 'exit':\n          {\n            const right = extension[key];\n            if (right) {\n              Object.assign(combined[key], right);\n            }\n            break;\n          }\n        // No default\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + stringifyPosition({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}","map":{"version":3,"names":["toString","parse","postprocess","preprocess","decodeNumericCharacterReference","decodeString","normalizeIdentifier","decodeNamedCharacterReference","stringifyPosition","own","hasOwnProperty","fromMarkdown","value","encoding","options","undefined","compiler","document","write","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","list","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcharacterreference","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","configure","mdastExtensions","compile","events","tree","type","children","context","stack","tokenStack","resume","listStack","index","length","push","tail","pop","prepareList","handler","call","Object","assign","sliceSerialize","defaultOnError","position","start","point","line","column","offset","end","containerBalance","listSpread","lineIndex","firstBlankLineIndex","atMarker","event","tailIndex","tailEvent","_spread","splice","item","create","and","open","token","node","errorHandler","parent","siblings","close","onExitError","Error","expectingFirstListItemValue","ancestor","Number","parseInt","lang","meta","flowCodeInside","replace","identifier","toLowerCase","title","url","depth","setextHeadingSlurpLineEnding","codePointAt","text","atHardBreak","includes","inReference","referenceType","string","fragment","alt","characterReferenceType","result","ordered","spread","checked","d","combined","extensions","Array","isArray","extension","key","right","left"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('mdast').Break} Break\r\n * @typedef {import('mdast').Blockquote} Blockquote\r\n * @typedef {import('mdast').Code} Code\r\n * @typedef {import('mdast').Definition} Definition\r\n * @typedef {import('mdast').Emphasis} Emphasis\r\n * @typedef {import('mdast').Heading} Heading\r\n * @typedef {import('mdast').Html} Html\r\n * @typedef {import('mdast').Image} Image\r\n * @typedef {import('mdast').InlineCode} InlineCode\r\n * @typedef {import('mdast').Link} Link\r\n * @typedef {import('mdast').List} List\r\n * @typedef {import('mdast').ListItem} ListItem\r\n * @typedef {import('mdast').Nodes} Nodes\r\n * @typedef {import('mdast').Paragraph} Paragraph\r\n * @typedef {import('mdast').Parent} Parent\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('mdast').ReferenceType} ReferenceType\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast').Strong} Strong\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\r\n *\r\n * @typedef {import('micromark-util-types').Encoding} Encoding\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Value} Value\r\n *\r\n * @typedef {import('unist').Point} Point\r\n *\r\n * @typedef {import('../index.js').CompileData} CompileData\r\n */\r\n\r\n/**\r\n * @typedef {Omit<Parent, 'children' | 'type'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\r\n */\r\n\r\n/**\r\n * @callback Transform\r\n *   Extra transform, to change the AST afterwards.\r\n * @param {Root} tree\r\n *   Tree to transform.\r\n * @returns {Root | null | undefined | void}\r\n *   New tree or nothing (in which case the current tree is used).\r\n *\r\n * @callback Handle\r\n *   Handle a token.\r\n * @param {CompileContext} this\r\n *   Context.\r\n * @param {Token} token\r\n *   Current token.\r\n * @returns {undefined | void}\r\n *   Nothing.\r\n *\r\n * @typedef {Record<string, Handle>} Handles\r\n *   Token types mapping to handles\r\n *\r\n * @callback OnEnterError\r\n *   Handle the case where the `right` token is open, but it is closed (by the\r\n *   `left` token) or because we reached the end of the document.\r\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\r\n *   Context.\r\n * @param {Token | undefined} left\r\n *   Left token.\r\n * @param {Token} right\r\n *   Right token.\r\n * @returns {undefined}\r\n *   Nothing.\r\n *\r\n * @callback OnExitError\r\n *   Handle the case where the `right` token is open but it is closed by\r\n *   exiting the `left` token.\r\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\r\n *   Context.\r\n * @param {Token} left\r\n *   Left token.\r\n * @param {Token} right\r\n *   Right token.\r\n * @returns {undefined}\r\n *   Nothing.\r\n *\r\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\r\n *   Open token on the stack, with an optional error handler for when\r\n *   that token isn’t closed properly.\r\n */\r\n\r\n/**\r\n * @typedef Config\r\n *   Configuration.\r\n *\r\n *   We have our defaults, but extensions will add more.\r\n * @property {Array<string>} canContainEols\r\n *   Token types where line endings are used.\r\n * @property {Handles} enter\r\n *   Opening handles.\r\n * @property {Handles} exit\r\n *   Closing handles.\r\n * @property {Array<Transform>} transforms\r\n *   Tree transforms.\r\n *\r\n * @typedef {Partial<Config>} Extension\r\n *   Change how markdown tokens from micromark are turned into mdast.\r\n *\r\n * @typedef CompileContext\r\n *   mdast compiler context.\r\n * @property {Array<Fragment | Nodes>} stack\r\n *   Stack of nodes.\r\n * @property {Array<TokenTuple>} tokenStack\r\n *   Stack of tokens.\r\n * @property {(this: CompileContext) => undefined} buffer\r\n *   Capture some of the output data.\r\n * @property {(this: CompileContext) => string} resume\r\n *   Stop capturing and access the output data.\r\n * @property {(this: CompileContext, node: Nodes, token: Token, onError?: OnEnterError) => undefined} enter\r\n *   Enter a node.\r\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => undefined} exit\r\n *   Exit a node.\r\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\r\n *   Get the string value of a token.\r\n * @property {Config} config\r\n *   Configuration.\r\n * @property {CompileData} data\r\n *   Info passed around; key/value store.\r\n *\r\n * @typedef FromMarkdownOptions\r\n *   Configuration for how to build mdast.\r\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\r\n *   Extensions for this utility to change how tokens are turned into a tree.\r\n *\r\n * @typedef {ParseOptions & FromMarkdownOptions} Options\r\n *   Configuration.\r\n */\r\n\r\nimport { toString } from 'mdast-util-to-string';\r\nimport { parse, postprocess, preprocess } from 'micromark';\r\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\r\nimport { decodeString } from 'micromark-util-decode-string';\r\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\r\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\r\nimport { stringifyPosition } from 'unist-util-stringify-position';\r\nconst own = {}.hasOwnProperty;\r\n\r\n/**\r\n * Turn markdown into a syntax tree.\r\n *\r\n * @overload\r\n * @param {Value} value\r\n * @param {Encoding | null | undefined} [encoding]\r\n * @param {Options | null | undefined} [options]\r\n * @returns {Root}\r\n *\r\n * @overload\r\n * @param {Value} value\r\n * @param {Options | null | undefined} [options]\r\n * @returns {Root}\r\n *\r\n * @param {Value} value\r\n *   Markdown to parse.\r\n * @param {Encoding | Options | null | undefined} [encoding]\r\n *   Character encoding for when `value` is `Buffer`.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {Root}\r\n *   mdast tree.\r\n */\r\nexport function fromMarkdown(value, encoding, options) {\r\n  if (typeof encoding !== 'string') {\r\n    options = encoding;\r\n    encoding = undefined;\r\n  }\r\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\r\n}\r\n\r\n/**\r\n * Note this compiler only understand complete buffering, not streaming.\r\n *\r\n * @param {Options | null | undefined} [options]\r\n */\r\nfunction compiler(options) {\r\n  /** @type {Config} */\r\n  const config = {\r\n    transforms: [],\r\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\r\n    enter: {\r\n      autolink: opener(link),\r\n      autolinkProtocol: onenterdata,\r\n      autolinkEmail: onenterdata,\r\n      atxHeading: opener(heading),\r\n      blockQuote: opener(blockQuote),\r\n      characterEscape: onenterdata,\r\n      characterReference: onenterdata,\r\n      codeFenced: opener(codeFlow),\r\n      codeFencedFenceInfo: buffer,\r\n      codeFencedFenceMeta: buffer,\r\n      codeIndented: opener(codeFlow, buffer),\r\n      codeText: opener(codeText, buffer),\r\n      codeTextData: onenterdata,\r\n      data: onenterdata,\r\n      codeFlowValue: onenterdata,\r\n      definition: opener(definition),\r\n      definitionDestinationString: buffer,\r\n      definitionLabelString: buffer,\r\n      definitionTitleString: buffer,\r\n      emphasis: opener(emphasis),\r\n      hardBreakEscape: opener(hardBreak),\r\n      hardBreakTrailing: opener(hardBreak),\r\n      htmlFlow: opener(html, buffer),\r\n      htmlFlowData: onenterdata,\r\n      htmlText: opener(html, buffer),\r\n      htmlTextData: onenterdata,\r\n      image: opener(image),\r\n      label: buffer,\r\n      link: opener(link),\r\n      listItem: opener(listItem),\r\n      listItemValue: onenterlistitemvalue,\r\n      listOrdered: opener(list, onenterlistordered),\r\n      listUnordered: opener(list),\r\n      paragraph: opener(paragraph),\r\n      reference: onenterreference,\r\n      referenceString: buffer,\r\n      resourceDestinationString: buffer,\r\n      resourceTitleString: buffer,\r\n      setextHeading: opener(heading),\r\n      strong: opener(strong),\r\n      thematicBreak: opener(thematicBreak)\r\n    },\r\n    exit: {\r\n      atxHeading: closer(),\r\n      atxHeadingSequence: onexitatxheadingsequence,\r\n      autolink: closer(),\r\n      autolinkEmail: onexitautolinkemail,\r\n      autolinkProtocol: onexitautolinkprotocol,\r\n      blockQuote: closer(),\r\n      characterEscapeValue: onexitdata,\r\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\r\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\r\n      characterReferenceValue: onexitcharacterreferencevalue,\r\n      characterReference: onexitcharacterreference,\r\n      codeFenced: closer(onexitcodefenced),\r\n      codeFencedFence: onexitcodefencedfence,\r\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\r\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\r\n      codeFlowValue: onexitdata,\r\n      codeIndented: closer(onexitcodeindented),\r\n      codeText: closer(onexitcodetext),\r\n      codeTextData: onexitdata,\r\n      data: onexitdata,\r\n      definition: closer(),\r\n      definitionDestinationString: onexitdefinitiondestinationstring,\r\n      definitionLabelString: onexitdefinitionlabelstring,\r\n      definitionTitleString: onexitdefinitiontitlestring,\r\n      emphasis: closer(),\r\n      hardBreakEscape: closer(onexithardbreak),\r\n      hardBreakTrailing: closer(onexithardbreak),\r\n      htmlFlow: closer(onexithtmlflow),\r\n      htmlFlowData: onexitdata,\r\n      htmlText: closer(onexithtmltext),\r\n      htmlTextData: onexitdata,\r\n      image: closer(onexitimage),\r\n      label: onexitlabel,\r\n      labelText: onexitlabeltext,\r\n      lineEnding: onexitlineending,\r\n      link: closer(onexitlink),\r\n      listItem: closer(),\r\n      listOrdered: closer(),\r\n      listUnordered: closer(),\r\n      paragraph: closer(),\r\n      referenceString: onexitreferencestring,\r\n      resourceDestinationString: onexitresourcedestinationstring,\r\n      resourceTitleString: onexitresourcetitlestring,\r\n      resource: onexitresource,\r\n      setextHeading: closer(onexitsetextheading),\r\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\r\n      setextHeadingText: onexitsetextheadingtext,\r\n      strong: closer(),\r\n      thematicBreak: closer()\r\n    }\r\n  };\r\n  configure(config, (options || {}).mdastExtensions || []);\r\n\r\n  /** @type {CompileData} */\r\n  const data = {};\r\n  return compile;\r\n\r\n  /**\r\n   * Turn micromark events into an mdast tree.\r\n   *\r\n   * @param {Array<Event>} events\r\n   *   Events.\r\n   * @returns {Root}\r\n   *   mdast tree.\r\n   */\r\n  function compile(events) {\r\n    /** @type {Root} */\r\n    let tree = {\r\n      type: 'root',\r\n      children: []\r\n    };\r\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\r\n    const context = {\r\n      stack: [tree],\r\n      tokenStack: [],\r\n      config,\r\n      enter,\r\n      exit,\r\n      buffer,\r\n      resume,\r\n      data\r\n    };\r\n    /** @type {Array<number>} */\r\n    const listStack = [];\r\n    let index = -1;\r\n    while (++index < events.length) {\r\n      // We preprocess lists to add `listItem` tokens, and to infer whether\r\n      // items the list itself are spread out.\r\n      if (events[index][1].type === \"listOrdered\" || events[index][1].type === \"listUnordered\") {\r\n        if (events[index][0] === 'enter') {\r\n          listStack.push(index);\r\n        } else {\r\n          const tail = listStack.pop();\r\n          index = prepareList(events, tail, index);\r\n        }\r\n      }\r\n    }\r\n    index = -1;\r\n    while (++index < events.length) {\r\n      const handler = config[events[index][0]];\r\n      if (own.call(handler, events[index][1].type)) {\r\n        handler[events[index][1].type].call(Object.assign({\r\n          sliceSerialize: events[index][2].sliceSerialize\r\n        }, context), events[index][1]);\r\n      }\r\n    }\r\n\r\n    // Handle tokens still being open.\r\n    if (context.tokenStack.length > 0) {\r\n      const tail = context.tokenStack[context.tokenStack.length - 1];\r\n      const handler = tail[1] || defaultOnError;\r\n      handler.call(context, undefined, tail[0]);\r\n    }\r\n\r\n    // Figure out `root` position.\r\n    tree.position = {\r\n      start: point(events.length > 0 ? events[0][1].start : {\r\n        line: 1,\r\n        column: 1,\r\n        offset: 0\r\n      }),\r\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\r\n        line: 1,\r\n        column: 1,\r\n        offset: 0\r\n      })\r\n    };\r\n\r\n    // Call transforms.\r\n    index = -1;\r\n    while (++index < config.transforms.length) {\r\n      tree = config.transforms[index](tree) || tree;\r\n    }\r\n    return tree;\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Event>} events\r\n   * @param {number} start\r\n   * @param {number} length\r\n   * @returns {number}\r\n   */\r\n  function prepareList(events, start, length) {\r\n    let index = start - 1;\r\n    let containerBalance = -1;\r\n    let listSpread = false;\r\n    /** @type {Token | undefined} */\r\n    let listItem;\r\n    /** @type {number | undefined} */\r\n    let lineIndex;\r\n    /** @type {number | undefined} */\r\n    let firstBlankLineIndex;\r\n    /** @type {boolean | undefined} */\r\n    let atMarker;\r\n    while (++index <= length) {\r\n      const event = events[index];\r\n      switch (event[1].type) {\r\n        case \"listUnordered\":\r\n        case \"listOrdered\":\r\n        case \"blockQuote\":\r\n          {\r\n            if (event[0] === 'enter') {\r\n              containerBalance++;\r\n            } else {\r\n              containerBalance--;\r\n            }\r\n            atMarker = undefined;\r\n            break;\r\n          }\r\n        case \"lineEndingBlank\":\r\n          {\r\n            if (event[0] === 'enter') {\r\n              if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\r\n                firstBlankLineIndex = index;\r\n              }\r\n              atMarker = undefined;\r\n            }\r\n            break;\r\n          }\r\n        case \"linePrefix\":\r\n        case \"listItemValue\":\r\n        case \"listItemMarker\":\r\n        case \"listItemPrefix\":\r\n        case \"listItemPrefixWhitespace\":\r\n          {\r\n            // Empty.\r\n\r\n            break;\r\n          }\r\n        default:\r\n          {\r\n            atMarker = undefined;\r\n          }\r\n      }\r\n      if (!containerBalance && event[0] === 'enter' && event[1].type === \"listItemPrefix\" || containerBalance === -1 && event[0] === 'exit' && (event[1].type === \"listUnordered\" || event[1].type === \"listOrdered\")) {\r\n        if (listItem) {\r\n          let tailIndex = index;\r\n          lineIndex = undefined;\r\n          while (tailIndex--) {\r\n            const tailEvent = events[tailIndex];\r\n            if (tailEvent[1].type === \"lineEnding\" || tailEvent[1].type === \"lineEndingBlank\") {\r\n              if (tailEvent[0] === 'exit') continue;\r\n              if (lineIndex) {\r\n                events[lineIndex][1].type = \"lineEndingBlank\";\r\n                listSpread = true;\r\n              }\r\n              tailEvent[1].type = \"lineEnding\";\r\n              lineIndex = tailIndex;\r\n            } else if (tailEvent[1].type === \"linePrefix\" || tailEvent[1].type === \"blockQuotePrefix\" || tailEvent[1].type === \"blockQuotePrefixWhitespace\" || tailEvent[1].type === \"blockQuoteMarker\" || tailEvent[1].type === \"listItemIndent\") {\r\n              // Empty\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\r\n            listItem._spread = true;\r\n          }\r\n\r\n          // Fix position.\r\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\r\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\r\n          index++;\r\n          length++;\r\n        }\r\n\r\n        // Create a new list item.\r\n        if (event[1].type === \"listItemPrefix\") {\r\n          /** @type {Token} */\r\n          const item = {\r\n            type: 'listItem',\r\n            _spread: false,\r\n            start: Object.assign({}, event[1].start),\r\n            // @ts-expect-error: we’ll add `end` in a second.\r\n            end: undefined\r\n          };\r\n          listItem = item;\r\n          events.splice(index, 0, ['enter', item, event[2]]);\r\n          index++;\r\n          length++;\r\n          firstBlankLineIndex = undefined;\r\n          atMarker = true;\r\n        }\r\n      }\r\n    }\r\n    events[start][1]._spread = listSpread;\r\n    return length;\r\n  }\r\n\r\n  /**\r\n   * Create an opener handle.\r\n   *\r\n   * @param {(token: Token) => Nodes} create\r\n   *   Create a node.\r\n   * @param {Handle | undefined} [and]\r\n   *   Optional function to also run.\r\n   * @returns {Handle}\r\n   *   Handle.\r\n   */\r\n  function opener(create, and) {\r\n    return open;\r\n\r\n    /**\r\n     * @this {CompileContext}\r\n     * @param {Token} token\r\n     * @returns {undefined}\r\n     */\r\n    function open(token) {\r\n      enter.call(this, create(token), token);\r\n      if (and) and.call(this, token);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @returns {undefined}\r\n   */\r\n  function buffer() {\r\n    this.stack.push({\r\n      type: 'fragment',\r\n      children: []\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   *   Context.\r\n   * @param {Nodes} node\r\n   *   Node to enter.\r\n   * @param {Token} token\r\n   *   Corresponding token.\r\n   * @param {OnEnterError | undefined} [errorHandler]\r\n   *   Handle the case where this token is open, but it is closed by something else.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  function enter(node, token, errorHandler) {\r\n    const parent = this.stack[this.stack.length - 1];\r\n    /** @type {Array<Nodes>} */\r\n    const siblings = parent.children;\r\n    siblings.push(node);\r\n    this.stack.push(node);\r\n    this.tokenStack.push([token, errorHandler]);\r\n    node.position = {\r\n      start: point(token.start),\r\n      // @ts-expect-error: `end` will be patched later.\r\n      end: undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a closer handle.\r\n   *\r\n   * @param {Handle | undefined} [and]\r\n   *   Optional function to also run.\r\n   * @returns {Handle}\r\n   *   Handle.\r\n   */\r\n  function closer(and) {\r\n    return close;\r\n\r\n    /**\r\n     * @this {CompileContext}\r\n     * @param {Token} token\r\n     * @returns {undefined}\r\n     */\r\n    function close(token) {\r\n      if (and) and.call(this, token);\r\n      exit.call(this, token);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   *   Context.\r\n   * @param {Token} token\r\n   *   Corresponding token.\r\n   * @param {OnExitError | undefined} [onExitError]\r\n   *   Handle the case where another token is open.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  function exit(token, onExitError) {\r\n    const node = this.stack.pop();\r\n    const open = this.tokenStack.pop();\r\n    if (!open) {\r\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\r\n        start: token.start,\r\n        end: token.end\r\n      }) + '): it’s not open');\r\n    } else if (open[0].type !== token.type) {\r\n      if (onExitError) {\r\n        onExitError.call(this, token, open[0]);\r\n      } else {\r\n        const handler = open[1] || defaultOnError;\r\n        handler.call(this, token, open[0]);\r\n      }\r\n    }\r\n    node.position.end = point(token.end);\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @returns {string}\r\n   */\r\n  function resume() {\r\n    return toString(this.stack.pop());\r\n  }\r\n\r\n  //\r\n  // Handlers.\r\n  //\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onenterlistordered() {\r\n    this.data.expectingFirstListItemValue = true;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onenterlistitemvalue(token) {\r\n    if (this.data.expectingFirstListItemValue) {\r\n      const ancestor = this.stack[this.stack.length - 2];\r\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\r\n      this.data.expectingFirstListItemValue = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitcodefencedfenceinfo() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.lang = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitcodefencedfencemeta() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.meta = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitcodefencedfence() {\r\n    // Exit if this is the closing fence.\r\n    if (this.data.flowCodeInside) return;\r\n    this.buffer();\r\n    this.data.flowCodeInside = true;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitcodefenced() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\r\n    this.data.flowCodeInside = undefined;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitcodeindented() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitdefinitionlabelstring(token) {\r\n    const label = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.label = label;\r\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitdefinitiontitlestring() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.title = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitdefinitiondestinationstring() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.url = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitatxheadingsequence(token) {\r\n    const node = this.stack[this.stack.length - 1];\r\n    if (!node.depth) {\r\n      const depth = this.sliceSerialize(token).length;\r\n      node.depth = depth;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitsetextheadingtext() {\r\n    this.data.setextHeadingSlurpLineEnding = true;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitsetextheadinglinesequence(token) {\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitsetextheading() {\r\n    this.data.setextHeadingSlurpLineEnding = undefined;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onenterdata(token) {\r\n    const node = this.stack[this.stack.length - 1];\r\n    /** @type {Array<Nodes>} */\r\n    const siblings = node.children;\r\n    let tail = siblings[siblings.length - 1];\r\n    if (!tail || tail.type !== 'text') {\r\n      // Add a new text node.\r\n      tail = text();\r\n      tail.position = {\r\n        start: point(token.start),\r\n        // @ts-expect-error: we’ll add `end` later.\r\n        end: undefined\r\n      };\r\n      siblings.push(tail);\r\n    }\r\n    this.stack.push(tail);\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitdata(token) {\r\n    const tail = this.stack.pop();\r\n    tail.value += this.sliceSerialize(token);\r\n    tail.position.end = point(token.end);\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitlineending(token) {\r\n    const context = this.stack[this.stack.length - 1];\r\n    // If we’re at a hard break, include the line ending in there.\r\n    if (this.data.atHardBreak) {\r\n      const tail = context.children[context.children.length - 1];\r\n      tail.position.end = point(token.end);\r\n      this.data.atHardBreak = undefined;\r\n      return;\r\n    }\r\n    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\r\n      onenterdata.call(this, token);\r\n      onexitdata.call(this, token);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexithardbreak() {\r\n    this.data.atHardBreak = true;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexithtmlflow() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.value = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexithtmltext() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.value = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitcodetext() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.value = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitlink() {\r\n    const node = this.stack[this.stack.length - 1];\r\n    // Note: there are also `identifier` and `label` fields on this link node!\r\n    // These are used / cleaned here.\r\n\r\n    // To do: clean.\r\n    if (this.data.inReference) {\r\n      /** @type {ReferenceType} */\r\n      const referenceType = this.data.referenceType || 'shortcut';\r\n      node.type += 'Reference';\r\n      // @ts-expect-error: mutate.\r\n      node.referenceType = referenceType;\r\n      // @ts-expect-error: mutate.\r\n      delete node.url;\r\n      delete node.title;\r\n    } else {\r\n      // @ts-expect-error: mutate.\r\n      delete node.identifier;\r\n      // @ts-expect-error: mutate.\r\n      delete node.label;\r\n    }\r\n    this.data.referenceType = undefined;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitimage() {\r\n    const node = this.stack[this.stack.length - 1];\r\n    // Note: there are also `identifier` and `label` fields on this link node!\r\n    // These are used / cleaned here.\r\n\r\n    // To do: clean.\r\n    if (this.data.inReference) {\r\n      /** @type {ReferenceType} */\r\n      const referenceType = this.data.referenceType || 'shortcut';\r\n      node.type += 'Reference';\r\n      // @ts-expect-error: mutate.\r\n      node.referenceType = referenceType;\r\n      // @ts-expect-error: mutate.\r\n      delete node.url;\r\n      delete node.title;\r\n    } else {\r\n      // @ts-expect-error: mutate.\r\n      delete node.identifier;\r\n      // @ts-expect-error: mutate.\r\n      delete node.label;\r\n    }\r\n    this.data.referenceType = undefined;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitlabeltext(token) {\r\n    const string = this.sliceSerialize(token);\r\n    const ancestor = this.stack[this.stack.length - 2];\r\n    // @ts-expect-error: stash this on the node, as it might become a reference\r\n    // later.\r\n    ancestor.label = decodeString(string);\r\n    // @ts-expect-error: same as above.\r\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitlabel() {\r\n    const fragment = this.stack[this.stack.length - 1];\r\n    const value = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    // Assume a reference.\r\n    this.data.inReference = true;\r\n    if (node.type === 'link') {\r\n      /** @type {Array<PhrasingContent>} */\r\n      const children = fragment.children;\r\n      node.children = children;\r\n    } else {\r\n      node.alt = value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitresourcedestinationstring() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.url = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitresourcetitlestring() {\r\n    const data = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.title = data;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitresource() {\r\n    this.data.inReference = undefined;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onenterreference() {\r\n    this.data.referenceType = 'collapsed';\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitreferencestring(token) {\r\n    const label = this.resume();\r\n    const node = this.stack[this.stack.length - 1];\r\n    // @ts-expect-error: stash this on the node, as it might become a reference\r\n    // later.\r\n    node.label = label;\r\n    // @ts-expect-error: same as above.\r\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\r\n    this.data.referenceType = 'full';\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n\r\n  function onexitcharacterreferencemarker(token) {\r\n    this.data.characterReferenceType = token.type;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitcharacterreferencevalue(token) {\r\n    const data = this.sliceSerialize(token);\r\n    const type = this.data.characterReferenceType;\r\n    /** @type {string} */\r\n    let value;\r\n    if (type) {\r\n      value = decodeNumericCharacterReference(data, type === \"characterReferenceMarkerNumeric\" ? 10 : 16);\r\n      this.data.characterReferenceType = undefined;\r\n    } else {\r\n      const result = decodeNamedCharacterReference(data);\r\n      value = result;\r\n    }\r\n    const tail = this.stack[this.stack.length - 1];\r\n    tail.value += value;\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitcharacterreference(token) {\r\n    const tail = this.stack.pop();\r\n    tail.position.end = point(token.end);\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitautolinkprotocol(token) {\r\n    onexitdata.call(this, token);\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.url = this.sliceSerialize(token);\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {Handle}\r\n   */\r\n  function onexitautolinkemail(token) {\r\n    onexitdata.call(this, token);\r\n    const node = this.stack[this.stack.length - 1];\r\n    node.url = 'mailto:' + this.sliceSerialize(token);\r\n  }\r\n\r\n  //\r\n  // Creaters.\r\n  //\r\n\r\n  /** @returns {Blockquote} */\r\n  function blockQuote() {\r\n    return {\r\n      type: 'blockquote',\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /** @returns {Code} */\r\n  function codeFlow() {\r\n    return {\r\n      type: 'code',\r\n      lang: null,\r\n      meta: null,\r\n      value: ''\r\n    };\r\n  }\r\n\r\n  /** @returns {InlineCode} */\r\n  function codeText() {\r\n    return {\r\n      type: 'inlineCode',\r\n      value: ''\r\n    };\r\n  }\r\n\r\n  /** @returns {Definition} */\r\n  function definition() {\r\n    return {\r\n      type: 'definition',\r\n      identifier: '',\r\n      label: null,\r\n      title: null,\r\n      url: ''\r\n    };\r\n  }\r\n\r\n  /** @returns {Emphasis} */\r\n  function emphasis() {\r\n    return {\r\n      type: 'emphasis',\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /** @returns {Heading} */\r\n  function heading() {\r\n    return {\r\n      type: 'heading',\r\n      // @ts-expect-error `depth` will be set later.\r\n      depth: 0,\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /** @returns {Break} */\r\n  function hardBreak() {\r\n    return {\r\n      type: 'break'\r\n    };\r\n  }\r\n\r\n  /** @returns {Html} */\r\n  function html() {\r\n    return {\r\n      type: 'html',\r\n      value: ''\r\n    };\r\n  }\r\n\r\n  /** @returns {Image} */\r\n  function image() {\r\n    return {\r\n      type: 'image',\r\n      title: null,\r\n      url: '',\r\n      alt: null\r\n    };\r\n  }\r\n\r\n  /** @returns {Link} */\r\n  function link() {\r\n    return {\r\n      type: 'link',\r\n      title: null,\r\n      url: '',\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @param {Token} token\r\n   * @returns {List}\r\n   */\r\n  function list(token) {\r\n    return {\r\n      type: 'list',\r\n      ordered: token.type === 'listOrdered',\r\n      start: null,\r\n      spread: token._spread,\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @param {Token} token\r\n   * @returns {ListItem}\r\n   */\r\n  function listItem(token) {\r\n    return {\r\n      type: 'listItem',\r\n      spread: token._spread,\r\n      checked: null,\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /** @returns {Paragraph} */\r\n  function paragraph() {\r\n    return {\r\n      type: 'paragraph',\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /** @returns {Strong} */\r\n  function strong() {\r\n    return {\r\n      type: 'strong',\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /** @returns {Text} */\r\n  function text() {\r\n    return {\r\n      type: 'text',\r\n      value: ''\r\n    };\r\n  }\r\n\r\n  /** @returns {ThematicBreak} */\r\n  function thematicBreak() {\r\n    return {\r\n      type: 'thematicBreak'\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Copy a point-like value.\r\n *\r\n * @param {Point} d\r\n *   Point-like value.\r\n * @returns {Point}\r\n *   unist point.\r\n */\r\nfunction point(d) {\r\n  return {\r\n    line: d.line,\r\n    column: d.column,\r\n    offset: d.offset\r\n  };\r\n}\r\n\r\n/**\r\n * @param {Config} combined\r\n * @param {Array<Array<Extension> | Extension>} extensions\r\n * @returns {undefined}\r\n */\r\nfunction configure(combined, extensions) {\r\n  let index = -1;\r\n  while (++index < extensions.length) {\r\n    const value = extensions[index];\r\n    if (Array.isArray(value)) {\r\n      configure(combined, value);\r\n    } else {\r\n      extension(combined, value);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Config} combined\r\n * @param {Extension} extension\r\n * @returns {undefined}\r\n */\r\nfunction extension(combined, extension) {\r\n  /** @type {keyof Extension} */\r\n  let key;\r\n  for (key in extension) {\r\n    if (own.call(extension, key)) {\r\n      switch (key) {\r\n        case 'canContainEols':\r\n          {\r\n            const right = extension[key];\r\n            if (right) {\r\n              combined[key].push(...right);\r\n            }\r\n            break;\r\n          }\r\n        case 'transforms':\r\n          {\r\n            const right = extension[key];\r\n            if (right) {\r\n              combined[key].push(...right);\r\n            }\r\n            break;\r\n          }\r\n        case 'enter':\r\n        case 'exit':\r\n          {\r\n            const right = extension[key];\r\n            if (right) {\r\n              Object.assign(combined[key], right);\r\n            }\r\n            break;\r\n          }\r\n        // No default\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** @type {OnEnterError} */\r\nfunction defaultOnError(left, right) {\r\n  if (left) {\r\n    throw new Error('Cannot close `' + left.type + '` (' + stringifyPosition({\r\n      start: left.start,\r\n      end: left.end\r\n    }) + '): a different token (`' + right.type + '`, ' + stringifyPosition({\r\n      start: right.start,\r\n      end: right.end\r\n    }) + ') is open');\r\n  } else {\r\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + stringifyPosition({\r\n      start: right.start,\r\n      end: right.end\r\n    }) + ') is still open');\r\n  }\r\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,QAAQ,QAAQ,sBAAsB;AAC/C,SAASC,KAAK,EAAEC,WAAW,EAAEC,UAAU,QAAQ,WAAW;AAC1D,SAASC,+BAA+B,QAAQ,mDAAmD;AACnG,SAASC,YAAY,QAAQ,8BAA8B;AAC3D,SAASC,mBAAmB,QAAQ,qCAAqC;AACzE,SAASC,6BAA6B,QAAQ,kCAAkC;AAChF,SAASC,iBAAiB,QAAQ,+BAA+B;AACjE,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EACrD,IAAI,OAAOD,QAAQ,KAAK,QAAQ,EAAE;IAChCC,OAAO,GAAGD,QAAQ;IAClBA,QAAQ,GAAGE,SAAS;EACtB;EA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}