{"ast":null,"code":"import { constants } from 'micromark-util-symbol';\n\n/**\r\n * Some of the internal operations of micromark do lots of editing\r\n * operations on very large arrays. This runs into problems with two\r\n * properties of most circa-2020 JavaScript interpreters:\r\n *\r\n *  - Array-length modifications at the high end of an array (push/pop) are\r\n *    expected to be common and are implemented in (amortized) time\r\n *    proportional to the number of elements added or removed, whereas\r\n *    other operations (shift/unshift and splice) are much less efficient.\r\n *  - Function arguments are passed on the stack, so adding tens of thousands\r\n *    of elements to an array with `arr.push[...newElements]` will frequently\r\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\r\n *\r\n * SpliceBuffers are an implementation of gap buffers, which are a\r\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\r\n * maintains a cursor, and moving the cursor has cost proportional to the\r\n * distance the cursor moves, but inserting, deleting, or splicing in\r\n * new information at the cursor is as efficient as the push/pop operation.\r\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\r\n * or unshifts) as long such edits happen at the same part of the array or\r\n * generally sweep through the array from the beginning to the end.\r\n *\r\n * The interface for splice buffers also supports large numbers of inputs by\r\n * passing a single array argument rather passing multiple arguments on the\r\n * function call stack.\r\n *\r\n * @template T\r\n *   Item type.\r\n */\nexport class SpliceBuffer {\n  /**\r\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\r\n   *   Initial items (optional).\r\n   * @returns\r\n   *   Splice buffer.\r\n   */\n  constructor(initial) {\n    /** @type {Array<T>} */\n    this.left = initial ? [...initial] : [];\n    /** @type {Array<T>} */\n    this.right = [];\n  }\n\n  /**\r\n   * Array access;\r\n   * does not move the cursor.\r\n   *\r\n   * @param {number} index\r\n   *   Index.\r\n   * @return {T}\r\n   *   Item.\r\n   */\n  get(index) {\n    if (index < 0 || index >= this.left.length + this.right.length) {\n      throw new RangeError('Cannot access index `' + index + '` in a splice buffer of size `' + (this.left.length + this.right.length) + '`');\n    }\n    if (index < this.left.length) return this.left[index];\n    return this.right[this.right.length - index + this.left.length - 1];\n  }\n\n  /**\r\n   * The length of the splice buffer, one greater than the largest index in the\r\n   * array.\r\n   */\n  get length() {\n    return this.left.length + this.right.length;\n  }\n\n  /**\r\n   * Remove and return `list[0]`;\r\n   * moves the cursor to `0`.\r\n   *\r\n   * @returns {T | undefined}\r\n   *   Item, optional.\r\n   */\n  shift() {\n    this.setCursor(0);\n    return this.right.pop();\n  }\n\n  /**\r\n   * Slice the buffer to get an array;\r\n   * does not move the cursor.\r\n   *\r\n   * @param {number} start\r\n   *   Start.\r\n   * @param {number | null | undefined} [end]\r\n   *   End (optional).\r\n   * @returns {Array<T>}\r\n   *   Array of items.\r\n   */\n  slice(start, end) {\n    /** @type {number} */\n    const stop = end === null || end === undefined ? Number.POSITIVE_INFINITY : end;\n    if (stop < this.left.length) {\n      return this.left.slice(start, stop);\n    }\n    if (start > this.left.length) {\n      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();\n    }\n    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());\n  }\n\n  /**\r\n   * Mimics the behavior of Array.prototype.splice() except for the change of\r\n   * interface necessary to avoid segfaults when patching in very large arrays.\r\n   *\r\n   * This operation moves cursor is moved to `start` and results in the cursor\r\n   * placed after any inserted items.\r\n   *\r\n   * @param {number} start\r\n   *   Start;\r\n   *   zero-based index at which to start changing the array;\r\n   *   negative numbers count backwards from the end of the array and values\r\n   *   that are out-of bounds are clamped to the appropriate end of the array.\r\n   * @param {number | null | undefined} [deleteCount=0]\r\n   *   Delete count (default: `0`);\r\n   *   maximum number of elements to delete, starting from start.\r\n   * @param {Array<T> | null | undefined} [items=[]]\r\n   *   Items to include in place of the deleted items (default: `[]`).\r\n   * @return {Array<T>}\r\n   *   Any removed items.\r\n   */\n  splice(start, deleteCount, items) {\n    /** @type {number} */\n    const count = deleteCount || 0;\n    this.setCursor(Math.trunc(start));\n    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);\n    if (items) chunkedPush(this.left, items);\n    return removed.reverse();\n  }\n\n  /**\r\n   * Remove and return the highest-numbered item in the array, so\r\n   * `list[list.length - 1]`;\r\n   * Moves the cursor to `length`.\r\n   *\r\n   * @returns {T | undefined}\r\n   *   Item, optional.\r\n   */\n  pop() {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    return this.left.pop();\n  }\n\n  /**\r\n   * Inserts a single item to the high-numbered side of the array;\r\n   * moves the cursor to `length`.\r\n   *\r\n   * @param {T} item\r\n   *   Item.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\n  push(item) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    this.left.push(item);\n  }\n\n  /**\r\n   * Inserts many items to the high-numbered side of the array.\r\n   * Moves the cursor to `length`.\r\n   *\r\n   * @param {Array<T>} items\r\n   *   Items.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\n  pushMany(items) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    chunkedPush(this.left, items);\n  }\n\n  /**\r\n   * Inserts a single item to the low-numbered side of the array;\r\n   * Moves the cursor to `0`.\r\n   *\r\n   * @param {T} item\r\n   *   Item.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\n  unshift(item) {\n    this.setCursor(0);\n    this.right.push(item);\n  }\n\n  /**\r\n   * Inserts many items to the low-numbered side of the array;\r\n   * moves the cursor to `0`.\r\n   *\r\n   * @param {Array<T>} items\r\n   *   Items.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\n  unshiftMany(items) {\n    this.setCursor(0);\n    chunkedPush(this.right, items.reverse());\n  }\n\n  /**\r\n   * Move the cursor to a specific position in the array. Requires\r\n   * time proportional to the distance moved.\r\n   *\r\n   * If `n < 0`, the cursor will end up at the beginning.\r\n   * If `n > length`, the cursor will end up at the end.\r\n   *\r\n   * @param {number} n\r\n   *   Position.\r\n   * @return {undefined}\r\n   *   Nothing.\r\n   */\n  setCursor(n) {\n    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;\n    if (n < this.left.length) {\n      // Move cursor to the this.left\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.right, removed.reverse());\n    } else {\n      // Move cursor to the this.right\n      const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.left, removed.reverse());\n    }\n  }\n}\n\n/**\r\n * Avoid stack overflow by pushing items onto the stack in segments\r\n *\r\n * @template T\r\n *   Item type.\r\n * @param {Array<T>} list\r\n *   List to inject into.\r\n * @param {ReadonlyArray<T>} right\r\n *   Items to inject.\r\n * @return {undefined}\r\n *   Nothing.\r\n */\nfunction chunkedPush(list, right) {\n  /** @type {number} */\n  let chunkStart = 0;\n  if (right.length < constants.v8MaxSafeChunkSize) {\n    list.push(...right);\n  } else {\n    while (chunkStart < right.length) {\n      list.push(...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize));\n      chunkStart += constants.v8MaxSafeChunkSize;\n    }\n  }\n}","map":{"version":3,"names":["constants","SpliceBuffer","constructor","initial","left","right","get","index","length","RangeError","shift","setCursor","pop","slice","start","end","stop","undefined","Number","POSITIVE_INFINITY","reverse","concat","splice","deleteCount","items","count","Math","trunc","removed","chunkedPush","push","item","pushMany","unshift","unshiftMany","n","list","chunkStart","v8MaxSafeChunkSize"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js"],"sourcesContent":["import {constants} from 'micromark-util-symbol'\r\n\r\n/**\r\n * Some of the internal operations of micromark do lots of editing\r\n * operations on very large arrays. This runs into problems with two\r\n * properties of most circa-2020 JavaScript interpreters:\r\n *\r\n *  - Array-length modifications at the high end of an array (push/pop) are\r\n *    expected to be common and are implemented in (amortized) time\r\n *    proportional to the number of elements added or removed, whereas\r\n *    other operations (shift/unshift and splice) are much less efficient.\r\n *  - Function arguments are passed on the stack, so adding tens of thousands\r\n *    of elements to an array with `arr.push[...newElements]` will frequently\r\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\r\n *\r\n * SpliceBuffers are an implementation of gap buffers, which are a\r\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\r\n * maintains a cursor, and moving the cursor has cost proportional to the\r\n * distance the cursor moves, but inserting, deleting, or splicing in\r\n * new information at the cursor is as efficient as the push/pop operation.\r\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\r\n * or unshifts) as long such edits happen at the same part of the array or\r\n * generally sweep through the array from the beginning to the end.\r\n *\r\n * The interface for splice buffers also supports large numbers of inputs by\r\n * passing a single array argument rather passing multiple arguments on the\r\n * function call stack.\r\n *\r\n * @template T\r\n *   Item type.\r\n */\r\nexport class SpliceBuffer {\r\n  /**\r\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\r\n   *   Initial items (optional).\r\n   * @returns\r\n   *   Splice buffer.\r\n   */\r\n  constructor(initial) {\r\n    /** @type {Array<T>} */\r\n    this.left = initial ? [...initial] : []\r\n    /** @type {Array<T>} */\r\n    this.right = []\r\n  }\r\n\r\n  /**\r\n   * Array access;\r\n   * does not move the cursor.\r\n   *\r\n   * @param {number} index\r\n   *   Index.\r\n   * @return {T}\r\n   *   Item.\r\n   */\r\n  get(index) {\r\n    if (index < 0 || index >= this.left.length + this.right.length) {\r\n      throw new RangeError(\r\n        'Cannot access index `' +\r\n          index +\r\n          '` in a splice buffer of size `' +\r\n          (this.left.length + this.right.length) +\r\n          '`'\r\n      )\r\n    }\r\n\r\n    if (index < this.left.length) return this.left[index]\r\n    return this.right[this.right.length - index + this.left.length - 1]\r\n  }\r\n\r\n  /**\r\n   * The length of the splice buffer, one greater than the largest index in the\r\n   * array.\r\n   */\r\n  get length() {\r\n    return this.left.length + this.right.length\r\n  }\r\n\r\n  /**\r\n   * Remove and return `list[0]`;\r\n   * moves the cursor to `0`.\r\n   *\r\n   * @returns {T | undefined}\r\n   *   Item, optional.\r\n   */\r\n  shift() {\r\n    this.setCursor(0)\r\n    return this.right.pop()\r\n  }\r\n\r\n  /**\r\n   * Slice the buffer to get an array;\r\n   * does not move the cursor.\r\n   *\r\n   * @param {number} start\r\n   *   Start.\r\n   * @param {number | null | undefined} [end]\r\n   *   End (optional).\r\n   * @returns {Array<T>}\r\n   *   Array of items.\r\n   */\r\n  slice(start, end) {\r\n    /** @type {number} */\r\n    const stop =\r\n      end === null || end === undefined ? Number.POSITIVE_INFINITY : end\r\n\r\n    if (stop < this.left.length) {\r\n      return this.left.slice(start, stop)\r\n    }\r\n\r\n    if (start > this.left.length) {\r\n      return this.right\r\n        .slice(\r\n          this.right.length - stop + this.left.length,\r\n          this.right.length - start + this.left.length\r\n        )\r\n        .reverse()\r\n    }\r\n\r\n    return this.left\r\n      .slice(start)\r\n      .concat(\r\n        this.right.slice(this.right.length - stop + this.left.length).reverse()\r\n      )\r\n  }\r\n\r\n  /**\r\n   * Mimics the behavior of Array.prototype.splice() except for the change of\r\n   * interface necessary to avoid segfaults when patching in very large arrays.\r\n   *\r\n   * This operation moves cursor is moved to `start` and results in the cursor\r\n   * placed after any inserted items.\r\n   *\r\n   * @param {number} start\r\n   *   Start;\r\n   *   zero-based index at which to start changing the array;\r\n   *   negative numbers count backwards from the end of the array and values\r\n   *   that are out-of bounds are clamped to the appropriate end of the array.\r\n   * @param {number | null | undefined} [deleteCount=0]\r\n   *   Delete count (default: `0`);\r\n   *   maximum number of elements to delete, starting from start.\r\n   * @param {Array<T> | null | undefined} [items=[]]\r\n   *   Items to include in place of the deleted items (default: `[]`).\r\n   * @return {Array<T>}\r\n   *   Any removed items.\r\n   */\r\n  splice(start, deleteCount, items) {\r\n    /** @type {number} */\r\n    const count = deleteCount || 0\r\n\r\n    this.setCursor(Math.trunc(start))\r\n    const removed = this.right.splice(\r\n      this.right.length - count,\r\n      Number.POSITIVE_INFINITY\r\n    )\r\n    if (items) chunkedPush(this.left, items)\r\n    return removed.reverse()\r\n  }\r\n\r\n  /**\r\n   * Remove and return the highest-numbered item in the array, so\r\n   * `list[list.length - 1]`;\r\n   * Moves the cursor to `length`.\r\n   *\r\n   * @returns {T | undefined}\r\n   *   Item, optional.\r\n   */\r\n  pop() {\r\n    this.setCursor(Number.POSITIVE_INFINITY)\r\n    return this.left.pop()\r\n  }\r\n\r\n  /**\r\n   * Inserts a single item to the high-numbered side of the array;\r\n   * moves the cursor to `length`.\r\n   *\r\n   * @param {T} item\r\n   *   Item.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  push(item) {\r\n    this.setCursor(Number.POSITIVE_INFINITY)\r\n    this.left.push(item)\r\n  }\r\n\r\n  /**\r\n   * Inserts many items to the high-numbered side of the array.\r\n   * Moves the cursor to `length`.\r\n   *\r\n   * @param {Array<T>} items\r\n   *   Items.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  pushMany(items) {\r\n    this.setCursor(Number.POSITIVE_INFINITY)\r\n    chunkedPush(this.left, items)\r\n  }\r\n\r\n  /**\r\n   * Inserts a single item to the low-numbered side of the array;\r\n   * Moves the cursor to `0`.\r\n   *\r\n   * @param {T} item\r\n   *   Item.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  unshift(item) {\r\n    this.setCursor(0)\r\n    this.right.push(item)\r\n  }\r\n\r\n  /**\r\n   * Inserts many items to the low-numbered side of the array;\r\n   * moves the cursor to `0`.\r\n   *\r\n   * @param {Array<T>} items\r\n   *   Items.\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  unshiftMany(items) {\r\n    this.setCursor(0)\r\n    chunkedPush(this.right, items.reverse())\r\n  }\r\n\r\n  /**\r\n   * Move the cursor to a specific position in the array. Requires\r\n   * time proportional to the distance moved.\r\n   *\r\n   * If `n < 0`, the cursor will end up at the beginning.\r\n   * If `n > length`, the cursor will end up at the end.\r\n   *\r\n   * @param {number} n\r\n   *   Position.\r\n   * @return {undefined}\r\n   *   Nothing.\r\n   */\r\n  setCursor(n) {\r\n    if (\r\n      n === this.left.length ||\r\n      (n > this.left.length && this.right.length === 0) ||\r\n      (n < 0 && this.left.length === 0)\r\n    )\r\n      return\r\n    if (n < this.left.length) {\r\n      // Move cursor to the this.left\r\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY)\r\n      chunkedPush(this.right, removed.reverse())\r\n    } else {\r\n      // Move cursor to the this.right\r\n      const removed = this.right.splice(\r\n        this.left.length + this.right.length - n,\r\n        Number.POSITIVE_INFINITY\r\n      )\r\n      chunkedPush(this.left, removed.reverse())\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Avoid stack overflow by pushing items onto the stack in segments\r\n *\r\n * @template T\r\n *   Item type.\r\n * @param {Array<T>} list\r\n *   List to inject into.\r\n * @param {ReadonlyArray<T>} right\r\n *   Items to inject.\r\n * @return {undefined}\r\n *   Nothing.\r\n */\r\nfunction chunkedPush(list, right) {\r\n  /** @type {number} */\r\n  let chunkStart = 0\r\n\r\n  if (right.length < constants.v8MaxSafeChunkSize) {\r\n    list.push(...right)\r\n  } else {\r\n    while (chunkStart < right.length) {\r\n      list.push(\r\n        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)\r\n      )\r\n      chunkStart += constants.v8MaxSafeChunkSize\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}