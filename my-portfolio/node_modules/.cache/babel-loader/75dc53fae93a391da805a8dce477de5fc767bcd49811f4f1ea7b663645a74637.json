{"ast":null,"code":"import { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nconst characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\n\n/**\r\n * Decode markdown strings (which occur in places such as fenced code info\r\n * strings, destinations, labels, and titles).\r\n *\r\n * The “string” content type allows character escapes and -references.\r\n * This decodes those.\r\n *\r\n * @param {string} value\r\n *   Value to decode.\r\n * @returns {string}\r\n *   Decoded value.\r\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode);\n}\n\n/**\r\n * @param {string} $0\r\n * @param {string} $1\r\n * @param {string} $2\r\n * @returns {string}\r\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1;\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0);\n  if (head === 35) {\n    const head = $2.charCodeAt(1);\n    const hex = head === 120 || head === 88;\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);\n  }\n  return decodeNamedCharacterReference($2) || $0;\n}","map":{"version":3,"names":["decodeNamedCharacterReference","decodeNumericCharacterReference","characterEscapeOrReference","decodeString","value","replace","decode","$0","$1","$2","head","charCodeAt","hex","slice"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/micromark-util-decode-string/index.js"],"sourcesContent":["import {decodeNamedCharacterReference} from 'decode-named-character-reference'\r\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\r\nconst characterEscapeOrReference =\r\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\r\n\r\n/**\r\n * Decode markdown strings (which occur in places such as fenced code info\r\n * strings, destinations, labels, and titles).\r\n *\r\n * The “string” content type allows character escapes and -references.\r\n * This decodes those.\r\n *\r\n * @param {string} value\r\n *   Value to decode.\r\n * @returns {string}\r\n *   Decoded value.\r\n */\r\nexport function decodeString(value) {\r\n  return value.replace(characterEscapeOrReference, decode)\r\n}\r\n\r\n/**\r\n * @param {string} $0\r\n * @param {string} $1\r\n * @param {string} $2\r\n * @returns {string}\r\n */\r\nfunction decode($0, $1, $2) {\r\n  if ($1) {\r\n    // Escape.\r\n    return $1\r\n  }\r\n\r\n  // Reference.\r\n  const head = $2.charCodeAt(0)\r\n  if (head === 35) {\r\n    const head = $2.charCodeAt(1)\r\n    const hex = head === 120 || head === 88\r\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\r\n  }\r\n  return decodeNamedCharacterReference($2) || $0\r\n}\r\n"],"mappings":"AAAA,SAAQA,6BAA6B,QAAO,kCAAkC;AAC9E,SAAQC,+BAA+B,QAAO,mDAAmD;AACjG,MAAMC,0BAA0B,GAC9B,mEAAmE;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACC,KAAK,EAAE;EAClC,OAAOA,KAAK,CAACC,OAAO,CAACH,0BAA0B,EAAEI,MAAM,CAAC;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAMA,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;EAC1B,IAAID,EAAE,EAAE;IACN;IACA,OAAOA,EAAE;EACX;;EAEA;EACA,MAAME,IAAI,GAAGD,EAAE,CAACE,UAAU,CAAC,CAAC,CAAC;EAC7B,IAAID,IAAI,KAAK,EAAE,EAAE;IACf,MAAMA,IAAI,GAAGD,EAAE,CAACE,UAAU,CAAC,CAAC,CAAC;IAC7B,MAAMC,GAAG,GAAGF,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,EAAE;IACvC,OAAOT,+BAA+B,CAACQ,EAAE,CAACI,KAAK,CAACD,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEA,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;EAC9E;EACA,OAAOZ,6BAA6B,CAACS,EAAE,CAAC,IAAIF,EAAE;AAChD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}