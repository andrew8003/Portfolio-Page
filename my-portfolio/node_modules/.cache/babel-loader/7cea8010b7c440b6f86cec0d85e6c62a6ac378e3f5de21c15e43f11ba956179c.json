{"ast":null,"code":"// To do: remove `void`s\n// To do: remove `null` from output of our APIs, allow it as user APIs.\n\n/**\r\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\r\n *   Callback.\r\n *\r\n * @typedef {(...input: Array<any>) => any} Middleware\r\n *   Ware.\r\n *\r\n * @typedef Pipeline\r\n *   Pipeline.\r\n * @property {Run} run\r\n *   Run the pipeline.\r\n * @property {Use} use\r\n *   Add middleware.\r\n *\r\n * @typedef {(...input: Array<any>) => void} Run\r\n *   Call all middleware.\r\n *\r\n *   Calls `done` on completion with either an error or the output of the\r\n *   last middleware.\r\n *\r\n *   > ðŸ‘‰ **Note**: as the length of input defines whether async functions get a\r\n *   > `next` function,\r\n *   > itâ€™s recommended to keep `input` at one value normally.\r\n\r\n *\r\n * @typedef {(fn: Middleware) => Pipeline} Use\r\n *   Add middleware.\r\n */\n\n/**\r\n * Create new middleware.\r\n *\r\n * @returns {Pipeline}\r\n *   Pipeline.\r\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = [];\n  /** @type {Pipeline} */\n  const pipeline = {\n    run,\n    use\n  };\n  return pipeline;\n\n  /** @type {Run} */\n  function run() {\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n    let middlewareIndex = -1;\n    /** @type {Callback} */\n    const callback = values.pop();\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback);\n    }\n    next(null, ...values);\n\n    /**\r\n     * Run the next `fn`, or weâ€™re done.\r\n     *\r\n     * @param {Error | null | undefined} error\r\n     * @param {Array<any>} output\r\n     */\n    function next(error) {\n      const fn = fns[++middlewareIndex];\n      let index = -1;\n      if (error) {\n        callback(error);\n        return;\n      }\n\n      // Copy non-nullish input into values.\n      for (var _len2 = arguments.length, output = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        output[_key2 - 1] = arguments[_key2];\n      }\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index];\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output;\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output);\n      } else {\n        callback(null, ...output);\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError('Expected `middelware` to be a function, not ' + middelware);\n    }\n    fns.push(middelware);\n    return pipeline;\n  }\n}\n\n/**\r\n * Wrap `middleware` into a uniform interface.\r\n *\r\n * You can pass all input to the resulting function.\r\n * `callback` is then called with the output of `middleware`.\r\n *\r\n * If `middleware` accepts more arguments than the later given in input,\r\n * an extra `done` function is passed to it after that input,\r\n * which must be called by `middleware`.\r\n *\r\n * The first value in `input` is the main input value.\r\n * All other input values are the rest input values.\r\n * The values given to `callback` are the input values,\r\n * merged with every non-nullish output value.\r\n *\r\n * * if `middleware` throws an error,\r\n *   returns a promise that is rejected,\r\n *   or calls the given `done` function with an error,\r\n *   `callback` is called with that error\r\n * * if `middleware` returns a value or returns a promise that is resolved,\r\n *   that value is the main output value\r\n * * if `middleware` calls `done`,\r\n *   all non-nullish values except for the first one (the error) overwrite the\r\n *   output values\r\n *\r\n * @param {Middleware} middleware\r\n *   Function to wrap.\r\n * @param {Callback} callback\r\n *   Callback called with the output of `middleware`.\r\n * @returns {Run}\r\n *   Wrapped middleware.\r\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called;\n  return wrapped;\n\n  /**\r\n   * Call `middleware`.\r\n   * @this {any}\r\n   * @param {Array<any>} parameters\r\n   * @returns {void}\r\n   */\n  function wrapped() {\n    for (var _len3 = arguments.length, parameters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      parameters[_key3] = arguments[_key3];\n    }\n    const fnExpectsCallback = middleware.length > parameters.length;\n    /** @type {any} */\n    let result;\n    if (fnExpectsCallback) {\n      parameters.push(done);\n    }\n    try {\n      result = middleware.apply(this, parameters);\n    } catch (error) {\n      const exception = /** @type {Error} */error;\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception;\n      }\n      return done(exception);\n    }\n    if (!fnExpectsCallback) {\n      if (result && result.then && typeof result.then === 'function') {\n        result.then(then, done);\n      } else if (result instanceof Error) {\n        done(result);\n      } else {\n        then(result);\n      }\n    }\n  }\n\n  /**\r\n   * Call `callback`, only once.\r\n   *\r\n   * @type {Callback}\r\n   */\n  function done(error) {\n    if (!called) {\n      called = true;\n      for (var _len4 = arguments.length, output = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        output[_key4 - 1] = arguments[_key4];\n      }\n      callback(error, ...output);\n    }\n  }\n\n  /**\r\n   * Call `done` with one value.\r\n   *\r\n   * @param {any} [value]\r\n   */\n  function then(value) {\n    done(null, value);\n  }\n}","map":{"version":3,"names":["trough","fns","pipeline","run","use","_len","arguments","length","values","Array","_key","middlewareIndex","callback","pop","TypeError","next","error","fn","index","_len2","output","_key2","undefined","wrap","middelware","push","middleware","called","wrapped","_len3","parameters","_key3","fnExpectsCallback","result","done","apply","exception","then","Error","_len4","_key4","value"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/trough/lib/index.js"],"sourcesContent":["// To do: remove `void`s\r\n// To do: remove `null` from output of our APIs, allow it as user APIs.\r\n\r\n/**\r\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\r\n *   Callback.\r\n *\r\n * @typedef {(...input: Array<any>) => any} Middleware\r\n *   Ware.\r\n *\r\n * @typedef Pipeline\r\n *   Pipeline.\r\n * @property {Run} run\r\n *   Run the pipeline.\r\n * @property {Use} use\r\n *   Add middleware.\r\n *\r\n * @typedef {(...input: Array<any>) => void} Run\r\n *   Call all middleware.\r\n *\r\n *   Calls `done` on completion with either an error or the output of the\r\n *   last middleware.\r\n *\r\n *   > ðŸ‘‰ **Note**: as the length of input defines whether async functions get a\r\n *   > `next` function,\r\n *   > itâ€™s recommended to keep `input` at one value normally.\r\n\r\n *\r\n * @typedef {(fn: Middleware) => Pipeline} Use\r\n *   Add middleware.\r\n */\r\n\r\n/**\r\n * Create new middleware.\r\n *\r\n * @returns {Pipeline}\r\n *   Pipeline.\r\n */\r\nexport function trough() {\r\n  /** @type {Array<Middleware>} */\r\n  const fns = []\r\n  /** @type {Pipeline} */\r\n  const pipeline = {run, use}\r\n\r\n  return pipeline\r\n\r\n  /** @type {Run} */\r\n  function run(...values) {\r\n    let middlewareIndex = -1\r\n    /** @type {Callback} */\r\n    const callback = values.pop()\r\n\r\n    if (typeof callback !== 'function') {\r\n      throw new TypeError('Expected function as last argument, not ' + callback)\r\n    }\r\n\r\n    next(null, ...values)\r\n\r\n    /**\r\n     * Run the next `fn`, or weâ€™re done.\r\n     *\r\n     * @param {Error | null | undefined} error\r\n     * @param {Array<any>} output\r\n     */\r\n    function next(error, ...output) {\r\n      const fn = fns[++middlewareIndex]\r\n      let index = -1\r\n\r\n      if (error) {\r\n        callback(error)\r\n        return\r\n      }\r\n\r\n      // Copy non-nullish input into values.\r\n      while (++index < values.length) {\r\n        if (output[index] === null || output[index] === undefined) {\r\n          output[index] = values[index]\r\n        }\r\n      }\r\n\r\n      // Save the newly created `output` for the next call.\r\n      values = output\r\n\r\n      // Next or done.\r\n      if (fn) {\r\n        wrap(fn, next)(...output)\r\n      } else {\r\n        callback(null, ...output)\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @type {Use} */\r\n  function use(middelware) {\r\n    if (typeof middelware !== 'function') {\r\n      throw new TypeError(\r\n        'Expected `middelware` to be a function, not ' + middelware\r\n      )\r\n    }\r\n\r\n    fns.push(middelware)\r\n    return pipeline\r\n  }\r\n}\r\n\r\n/**\r\n * Wrap `middleware` into a uniform interface.\r\n *\r\n * You can pass all input to the resulting function.\r\n * `callback` is then called with the output of `middleware`.\r\n *\r\n * If `middleware` accepts more arguments than the later given in input,\r\n * an extra `done` function is passed to it after that input,\r\n * which must be called by `middleware`.\r\n *\r\n * The first value in `input` is the main input value.\r\n * All other input values are the rest input values.\r\n * The values given to `callback` are the input values,\r\n * merged with every non-nullish output value.\r\n *\r\n * * if `middleware` throws an error,\r\n *   returns a promise that is rejected,\r\n *   or calls the given `done` function with an error,\r\n *   `callback` is called with that error\r\n * * if `middleware` returns a value or returns a promise that is resolved,\r\n *   that value is the main output value\r\n * * if `middleware` calls `done`,\r\n *   all non-nullish values except for the first one (the error) overwrite the\r\n *   output values\r\n *\r\n * @param {Middleware} middleware\r\n *   Function to wrap.\r\n * @param {Callback} callback\r\n *   Callback called with the output of `middleware`.\r\n * @returns {Run}\r\n *   Wrapped middleware.\r\n */\r\nexport function wrap(middleware, callback) {\r\n  /** @type {boolean} */\r\n  let called\r\n\r\n  return wrapped\r\n\r\n  /**\r\n   * Call `middleware`.\r\n   * @this {any}\r\n   * @param {Array<any>} parameters\r\n   * @returns {void}\r\n   */\r\n  function wrapped(...parameters) {\r\n    const fnExpectsCallback = middleware.length > parameters.length\r\n    /** @type {any} */\r\n    let result\r\n\r\n    if (fnExpectsCallback) {\r\n      parameters.push(done)\r\n    }\r\n\r\n    try {\r\n      result = middleware.apply(this, parameters)\r\n    } catch (error) {\r\n      const exception = /** @type {Error} */ (error)\r\n\r\n      // Well, this is quite the pickle.\r\n      // `middleware` received a callback and called it synchronously, but that\r\n      // threw an error.\r\n      // The only thing left to do is to throw the thing instead.\r\n      if (fnExpectsCallback && called) {\r\n        throw exception\r\n      }\r\n\r\n      return done(exception)\r\n    }\r\n\r\n    if (!fnExpectsCallback) {\r\n      if (result && result.then && typeof result.then === 'function') {\r\n        result.then(then, done)\r\n      } else if (result instanceof Error) {\r\n        done(result)\r\n      } else {\r\n        then(result)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call `callback`, only once.\r\n   *\r\n   * @type {Callback}\r\n   */\r\n  function done(error, ...output) {\r\n    if (!called) {\r\n      called = true\r\n      callback(error, ...output)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call `done` with one value.\r\n   *\r\n   * @param {any} [value]\r\n   */\r\n  function then(value) {\r\n    done(null, value)\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}