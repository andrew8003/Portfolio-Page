{"ast":null,"code":"// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const minpath = {\n  basename,\n  dirname,\n  extname,\n  join,\n  sep: '/'\n};\n\n/* eslint-disable max-depth, complexity */\n\n/**\r\n * Get the basename from a path.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @param {string | null | undefined} [extname]\r\n *   Extension to strip.\r\n * @returns {string}\r\n *   Stem or basename.\r\n */\nfunction basename(path, extname) {\n  if (extname !== undefined && typeof extname !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string');\n  }\n  assertPath(path);\n  let start = 0;\n  let end = -1;\n  let index = path.length;\n  /** @type {boolean | undefined} */\n  let seenNonSlash;\n  if (extname === undefined || extname.length === 0 || extname.length > path.length) {\n    while (index--) {\n      if (path.codePointAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1;\n          break;\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true;\n        end = index + 1;\n      }\n    }\n    return end < 0 ? '' : path.slice(start, end);\n  }\n  if (extname === path) {\n    return '';\n  }\n  let firstNonSlashEnd = -1;\n  let extnameIndex = extname.length - 1;\n  while (index--) {\n    if (path.codePointAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1;\n        break;\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true;\n        firstNonSlashEnd = index + 1;\n      }\n      if (extnameIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.codePointAt(index) === extname.codePointAt(extnameIndex--)) {\n          if (extnameIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index;\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extnameIndex = -1;\n          end = firstNonSlashEnd;\n        }\n      }\n    }\n  }\n  if (start === end) {\n    end = firstNonSlashEnd;\n  } else if (end < 0) {\n    end = path.length;\n  }\n  return path.slice(start, end);\n}\n\n/**\r\n * Get the dirname from a path.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @returns {string}\r\n *   File path.\r\n */\nfunction dirname(path) {\n  assertPath(path);\n  if (path.length === 0) {\n    return '.';\n  }\n  let end = -1;\n  let index = path.length;\n  /** @type {boolean | undefined} */\n  let unmatchedSlash;\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.codePointAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index;\n        break;\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true;\n    }\n  }\n  return end < 0 ? path.codePointAt(0) === 47 /* `/` */ ? '/' : '.' : end === 1 && path.codePointAt(0) === 47 /* `/` */ ? '//' : path.slice(0, end);\n}\n\n/**\r\n * Get an extname from a path.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @returns {string}\r\n *   Extname.\r\n */\nfunction extname(path) {\n  assertPath(path);\n  let index = path.length;\n  let end = -1;\n  let startPart = 0;\n  let startDot = -1;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0;\n  /** @type {boolean | undefined} */\n  let unmatchedSlash;\n  while (index--) {\n    const code = path.codePointAt(index);\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1;\n        break;\n      }\n      continue;\n    }\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true;\n      end = index + 1;\n    }\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index;\n      } else if (preDotState !== 1) {\n        preDotState = 1;\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1;\n    }\n  }\n  if (startDot < 0 || end < 0 ||\n  // We saw a non-dot character immediately before the dot.\n  preDotState === 0 ||\n  // The (right-most) trimmed path component is exactly `..`.\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n}\n\n/**\r\n * Join segments from a path.\r\n *\r\n * @param {Array<string>} segments\r\n *   Path segments.\r\n * @returns {string}\r\n *   File path.\r\n */\nfunction join(...segments) {\n  let index = -1;\n  /** @type {string | undefined} */\n  let joined;\n  while (++index < segments.length) {\n    assertPath(segments[index]);\n    if (segments[index]) {\n      joined = joined === undefined ? segments[index] : joined + '/' + segments[index];\n    }\n  }\n  return joined === undefined ? '.' : normalize(joined);\n}\n\n/**\r\n * Normalize a basic file path.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @returns {string}\r\n *   File path.\r\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  assertPath(path);\n  const absolute = path.codePointAt(0) === 47; /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute);\n  if (value.length === 0 && !absolute) {\n    value = '.';\n  }\n  if (value.length > 0 && path.codePointAt(path.length - 1) === 47 /* / */) {\n    value += '/';\n  }\n  return absolute ? '/' + value : value;\n}\n\n/**\r\n * Resolve `.` and `..` elements in a path with directory names.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @param {boolean} allowAboveRoot\r\n *   Whether `..` can move above root.\r\n * @returns {string}\r\n *   File path.\r\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let index = -1;\n  /** @type {number | undefined} */\n  let code;\n  /** @type {number} */\n  let lastSlashIndex;\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.codePointAt(index);\n    } else if (code === 47 /* `/` */) {\n      break;\n    } else {\n      code = 47; /* `/` */\n    }\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 /* `.` */ || result.codePointAt(result.length - 2) !== 46 /* `.` */) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/');\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = '';\n                lastSegmentLength = 0;\n              } else {\n                result = result.slice(0, lastSlashIndex);\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/');\n              }\n              lastSlash = index;\n              dots = 0;\n              continue;\n            }\n          } else if (result.length > 0) {\n            result = '';\n            lastSegmentLength = 0;\n            lastSlash = index;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index);\n        } else {\n          result = path.slice(lastSlash + 1, index);\n        }\n        lastSegmentLength = index - lastSlash - 1;\n      }\n      lastSlash = index;\n      dots = 0;\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++;\n    } else {\n      dots = -1;\n    }\n  }\n  return result;\n}\n\n/**\r\n * Make sure `path` is a string.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @returns {asserts path is string}\r\n *   Nothing.\r\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n/* eslint-enable max-depth, complexity */","map":{"version":3,"names":["minpath","basename","dirname","extname","join","sep","path","undefined","TypeError","assertPath","start","end","index","length","seenNonSlash","codePointAt","slice","firstNonSlashEnd","extnameIndex","unmatchedSlash","startPart","startDot","preDotState","code","segments","joined","normalize","absolute","value","normalizeString","allowAboveRoot","result","lastSegmentLength","lastSlash","dots","lastSlashIndex","lastIndexOf","JSON","stringify"],"sources":["C:/Users/Andrew/Documents/GitHub/Portfolio-Page/my-portfolio/node_modules/vfile/lib/minpath.browser.js"],"sourcesContent":["// A derivative work based on:\r\n// <https://github.com/browserify/path-browserify>.\r\n// Which is licensed:\r\n//\r\n// MIT License\r\n//\r\n// Copyright (c) 2013 James Halliday\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n// the Software, and to permit persons to whom the Software is furnished to do so,\r\n// subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n// A derivative work based on:\r\n//\r\n// Parts of that are extracted from Node’s internal `path` module:\r\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\r\n// Which is licensed:\r\n//\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nexport const minpath = {basename, dirname, extname, join, sep: '/'}\r\n\r\n/* eslint-disable max-depth, complexity */\r\n\r\n/**\r\n * Get the basename from a path.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @param {string | null | undefined} [extname]\r\n *   Extension to strip.\r\n * @returns {string}\r\n *   Stem or basename.\r\n */\r\nfunction basename(path, extname) {\r\n  if (extname !== undefined && typeof extname !== 'string') {\r\n    throw new TypeError('\"ext\" argument must be a string')\r\n  }\r\n\r\n  assertPath(path)\r\n  let start = 0\r\n  let end = -1\r\n  let index = path.length\r\n  /** @type {boolean | undefined} */\r\n  let seenNonSlash\r\n\r\n  if (\r\n    extname === undefined ||\r\n    extname.length === 0 ||\r\n    extname.length > path.length\r\n  ) {\r\n    while (index--) {\r\n      if (path.codePointAt(index) === 47 /* `/` */) {\r\n        // If we reached a path separator that was not part of a set of path\r\n        // separators at the end of the string, stop now.\r\n        if (seenNonSlash) {\r\n          start = index + 1\r\n          break\r\n        }\r\n      } else if (end < 0) {\r\n        // We saw the first non-path separator, mark this as the end of our\r\n        // path component.\r\n        seenNonSlash = true\r\n        end = index + 1\r\n      }\r\n    }\r\n\r\n    return end < 0 ? '' : path.slice(start, end)\r\n  }\r\n\r\n  if (extname === path) {\r\n    return ''\r\n  }\r\n\r\n  let firstNonSlashEnd = -1\r\n  let extnameIndex = extname.length - 1\r\n\r\n  while (index--) {\r\n    if (path.codePointAt(index) === 47 /* `/` */) {\r\n      // If we reached a path separator that was not part of a set of path\r\n      // separators at the end of the string, stop now.\r\n      if (seenNonSlash) {\r\n        start = index + 1\r\n        break\r\n      }\r\n    } else {\r\n      if (firstNonSlashEnd < 0) {\r\n        // We saw the first non-path separator, remember this index in case\r\n        // we need it if the extension ends up not matching.\r\n        seenNonSlash = true\r\n        firstNonSlashEnd = index + 1\r\n      }\r\n\r\n      if (extnameIndex > -1) {\r\n        // Try to match the explicit extension.\r\n        if (path.codePointAt(index) === extname.codePointAt(extnameIndex--)) {\r\n          if (extnameIndex < 0) {\r\n            // We matched the extension, so mark this as the end of our path\r\n            // component\r\n            end = index\r\n          }\r\n        } else {\r\n          // Extension does not match, so our result is the entire path\r\n          // component\r\n          extnameIndex = -1\r\n          end = firstNonSlashEnd\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (start === end) {\r\n    end = firstNonSlashEnd\r\n  } else if (end < 0) {\r\n    end = path.length\r\n  }\r\n\r\n  return path.slice(start, end)\r\n}\r\n\r\n/**\r\n * Get the dirname from a path.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @returns {string}\r\n *   File path.\r\n */\r\nfunction dirname(path) {\r\n  assertPath(path)\r\n\r\n  if (path.length === 0) {\r\n    return '.'\r\n  }\r\n\r\n  let end = -1\r\n  let index = path.length\r\n  /** @type {boolean | undefined} */\r\n  let unmatchedSlash\r\n\r\n  // Prefix `--` is important to not run on `0`.\r\n  while (--index) {\r\n    if (path.codePointAt(index) === 47 /* `/` */) {\r\n      if (unmatchedSlash) {\r\n        end = index\r\n        break\r\n      }\r\n    } else if (!unmatchedSlash) {\r\n      // We saw the first non-path separator\r\n      unmatchedSlash = true\r\n    }\r\n  }\r\n\r\n  return end < 0\r\n    ? path.codePointAt(0) === 47 /* `/` */\r\n      ? '/'\r\n      : '.'\r\n    : end === 1 && path.codePointAt(0) === 47 /* `/` */\r\n      ? '//'\r\n      : path.slice(0, end)\r\n}\r\n\r\n/**\r\n * Get an extname from a path.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @returns {string}\r\n *   Extname.\r\n */\r\nfunction extname(path) {\r\n  assertPath(path)\r\n\r\n  let index = path.length\r\n\r\n  let end = -1\r\n  let startPart = 0\r\n  let startDot = -1\r\n  // Track the state of characters (if any) we see before our first dot and\r\n  // after any path separator we find.\r\n  let preDotState = 0\r\n  /** @type {boolean | undefined} */\r\n  let unmatchedSlash\r\n\r\n  while (index--) {\r\n    const code = path.codePointAt(index)\r\n\r\n    if (code === 47 /* `/` */) {\r\n      // If we reached a path separator that was not part of a set of path\r\n      // separators at the end of the string, stop now.\r\n      if (unmatchedSlash) {\r\n        startPart = index + 1\r\n        break\r\n      }\r\n\r\n      continue\r\n    }\r\n\r\n    if (end < 0) {\r\n      // We saw the first non-path separator, mark this as the end of our\r\n      // extension.\r\n      unmatchedSlash = true\r\n      end = index + 1\r\n    }\r\n\r\n    if (code === 46 /* `.` */) {\r\n      // If this is our first dot, mark it as the start of our extension.\r\n      if (startDot < 0) {\r\n        startDot = index\r\n      } else if (preDotState !== 1) {\r\n        preDotState = 1\r\n      }\r\n    } else if (startDot > -1) {\r\n      // We saw a non-dot and non-path separator before our dot, so we should\r\n      // have a good chance at having a non-empty extension.\r\n      preDotState = -1\r\n    }\r\n  }\r\n\r\n  if (\r\n    startDot < 0 ||\r\n    end < 0 ||\r\n    // We saw a non-dot character immediately before the dot.\r\n    preDotState === 0 ||\r\n    // The (right-most) trimmed path component is exactly `..`.\r\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\r\n  ) {\r\n    return ''\r\n  }\r\n\r\n  return path.slice(startDot, end)\r\n}\r\n\r\n/**\r\n * Join segments from a path.\r\n *\r\n * @param {Array<string>} segments\r\n *   Path segments.\r\n * @returns {string}\r\n *   File path.\r\n */\r\nfunction join(...segments) {\r\n  let index = -1\r\n  /** @type {string | undefined} */\r\n  let joined\r\n\r\n  while (++index < segments.length) {\r\n    assertPath(segments[index])\r\n\r\n    if (segments[index]) {\r\n      joined =\r\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\r\n    }\r\n  }\r\n\r\n  return joined === undefined ? '.' : normalize(joined)\r\n}\r\n\r\n/**\r\n * Normalize a basic file path.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @returns {string}\r\n *   File path.\r\n */\r\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\r\n// manually removed from it.\r\nfunction normalize(path) {\r\n  assertPath(path)\r\n\r\n  const absolute = path.codePointAt(0) === 47 /* `/` */\r\n\r\n  // Normalize the path according to POSIX rules.\r\n  let value = normalizeString(path, !absolute)\r\n\r\n  if (value.length === 0 && !absolute) {\r\n    value = '.'\r\n  }\r\n\r\n  if (value.length > 0 && path.codePointAt(path.length - 1) === 47 /* / */) {\r\n    value += '/'\r\n  }\r\n\r\n  return absolute ? '/' + value : value\r\n}\r\n\r\n/**\r\n * Resolve `.` and `..` elements in a path with directory names.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @param {boolean} allowAboveRoot\r\n *   Whether `..` can move above root.\r\n * @returns {string}\r\n *   File path.\r\n */\r\nfunction normalizeString(path, allowAboveRoot) {\r\n  let result = ''\r\n  let lastSegmentLength = 0\r\n  let lastSlash = -1\r\n  let dots = 0\r\n  let index = -1\r\n  /** @type {number | undefined} */\r\n  let code\r\n  /** @type {number} */\r\n  let lastSlashIndex\r\n\r\n  while (++index <= path.length) {\r\n    if (index < path.length) {\r\n      code = path.codePointAt(index)\r\n    } else if (code === 47 /* `/` */) {\r\n      break\r\n    } else {\r\n      code = 47 /* `/` */\r\n    }\r\n\r\n    if (code === 47 /* `/` */) {\r\n      if (lastSlash === index - 1 || dots === 1) {\r\n        // Empty.\r\n      } else if (lastSlash !== index - 1 && dots === 2) {\r\n        if (\r\n          result.length < 2 ||\r\n          lastSegmentLength !== 2 ||\r\n          result.codePointAt(result.length - 1) !== 46 /* `.` */ ||\r\n          result.codePointAt(result.length - 2) !== 46 /* `.` */\r\n        ) {\r\n          if (result.length > 2) {\r\n            lastSlashIndex = result.lastIndexOf('/')\r\n\r\n            if (lastSlashIndex !== result.length - 1) {\r\n              if (lastSlashIndex < 0) {\r\n                result = ''\r\n                lastSegmentLength = 0\r\n              } else {\r\n                result = result.slice(0, lastSlashIndex)\r\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\r\n              }\r\n\r\n              lastSlash = index\r\n              dots = 0\r\n              continue\r\n            }\r\n          } else if (result.length > 0) {\r\n            result = ''\r\n            lastSegmentLength = 0\r\n            lastSlash = index\r\n            dots = 0\r\n            continue\r\n          }\r\n        }\r\n\r\n        if (allowAboveRoot) {\r\n          result = result.length > 0 ? result + '/..' : '..'\r\n          lastSegmentLength = 2\r\n        }\r\n      } else {\r\n        if (result.length > 0) {\r\n          result += '/' + path.slice(lastSlash + 1, index)\r\n        } else {\r\n          result = path.slice(lastSlash + 1, index)\r\n        }\r\n\r\n        lastSegmentLength = index - lastSlash - 1\r\n      }\r\n\r\n      lastSlash = index\r\n      dots = 0\r\n    } else if (code === 46 /* `.` */ && dots > -1) {\r\n      dots++\r\n    } else {\r\n      dots = -1\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Make sure `path` is a string.\r\n *\r\n * @param {string} path\r\n *   File path.\r\n * @returns {asserts path is string}\r\n *   Nothing.\r\n */\r\nfunction assertPath(path) {\r\n  if (typeof path !== 'string') {\r\n    throw new TypeError(\r\n      'Path must be a string. Received ' + JSON.stringify(path)\r\n    )\r\n  }\r\n}\r\n\r\n/* eslint-enable max-depth, complexity */\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMA,OAAO,GAAG;EAACC,QAAQ;EAAEC,OAAO;EAAEC,OAAO;EAAEC,IAAI;EAAEC,GAAG,EAAE;AAAG,CAAC;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,QAAQA,CAACK,IAAI,EAAEH,OAAO,EAAE;EAC/B,IAAIA,OAAO,KAAKI,SAAS,IAAI,OAAOJ,OAAO,KAAK,QAAQ,EAAE;IACxD,MAAM,IAAIK,SAAS,CAAC,iCAAiC,CAAC;EACxD;EAEAC,UAAU,CAACH,IAAI,CAAC;EAChB,IAAII,KAAK,GAAG,CAAC;EACb,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZ,IAAIC,KAAK,GAAGN,IAAI,CAACO,MAAM;EACvB;EACA,IAAIC,YAAY;EAEhB,IACEX,OAAO,KAAKI,SAAS,IACrBJ,OAAO,CAACU,MAAM,KAAK,CAAC,IACpBV,OAAO,CAACU,MAAM,GAAGP,IAAI,CAACO,MAAM,EAC5B;IACA,OAAOD,KAAK,EAAE,EAAE;MACd,IAAIN,IAAI,CAACS,WAAW,CAACH,KAAK,CAAC,KAAK,EAAE,CAAC,WAAW;QAC5C;QACA;QACA,IAAIE,YAAY,EAAE;UAChBJ,KAAK,GAAGE,KAAK,GAAG,CAAC;UACjB;QACF;MACF,CAAC,MAAM,IAAID,GAAG,GAAG,CAAC,EAAE;QAClB;QACA;QACAG,YAAY,GAAG,IAAI;QACnBH,GAAG,GAAGC,KAAK,GAAG,CAAC;MACjB;IACF;IAEA,OAAOD,GAAG,GAAG,CAAC,GAAG,EAAE,GAAGL,IAAI,CAACU,KAAK,CAACN,KAAK,EAAEC,GAAG,CAAC;EAC9C;EAEA,IAAIR,OAAO,KAAKG,IAAI,EAAE;IACpB,OAAO,EAAE;EACX;EAEA,IAAIW,gBAAgB,GAAG,CAAC,CAAC;EACzB,IAAIC,YAAY,GAAGf,OAAO,CAACU,MAAM,GAAG,CAAC;EAErC,OAAOD,KAAK,EAAE,EAAE;IACd,IAAIN,IAAI,CAACS,WAAW,CAACH,KAAK,CAAC,KAAK,EAAE,CAAC,WAAW;MAC5C;MACA;MACA,IAAIE,YAAY,EAAE;QAChBJ,KAAK,GAAGE,KAAK,GAAG,CAAC;QACjB;MACF;IACF,CAAC,MAAM;MACL,IAAIK,gBAAgB,GAAG,CAAC,EAAE;QACxB;QACA;QACAH,YAAY,GAAG,IAAI;QACnBG,gBAAgB,GAAGL,KAAK,GAAG,CAAC;MAC9B;MAEA,IAAIM,YAAY,GAAG,CAAC,CAAC,EAAE;QACrB;QACA,IAAIZ,IAAI,CAACS,WAAW,CAACH,KAAK,CAAC,KAAKT,OAAO,CAACY,WAAW,CAACG,YAAY,EAAE,CAAC,EAAE;UACnE,IAAIA,YAAY,GAAG,CAAC,EAAE;YACpB;YACA;YACAP,GAAG,GAAGC,KAAK;UACb;QACF,CAAC,MAAM;UACL;UACA;UACAM,YAAY,GAAG,CAAC,CAAC;UACjBP,GAAG,GAAGM,gBAAgB;QACxB;MACF;IACF;EACF;EAEA,IAAIP,KAAK,KAAKC,GAAG,EAAE;IACjBA,GAAG,GAAGM,gBAAgB;EACxB,CAAC,MAAM,IAAIN,GAAG,GAAG,CAAC,EAAE;IAClBA,GAAG,GAAGL,IAAI,CAACO,MAAM;EACnB;EAEA,OAAOP,IAAI,CAACU,KAAK,CAACN,KAAK,EAAEC,GAAG,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAST,OAAOA,CAACI,IAAI,EAAE;EACrBG,UAAU,CAACH,IAAI,CAAC;EAEhB,IAAIA,IAAI,CAACO,MAAM,KAAK,CAAC,EAAE;IACrB,OAAO,GAAG;EACZ;EAEA,IAAIF,GAAG,GAAG,CAAC,CAAC;EACZ,IAAIC,KAAK,GAAGN,IAAI,CAACO,MAAM;EACvB;EACA,IAAIM,cAAc;;EAElB;EACA,OAAO,EAAEP,KAAK,EAAE;IACd,IAAIN,IAAI,CAACS,WAAW,CAACH,KAAK,CAAC,KAAK,EAAE,CAAC,WAAW;MAC5C,IAAIO,cAAc,EAAE;QAClBR,GAAG,GAAGC,KAAK;QACX;MACF;IACF,CAAC,MAAM,IAAI,CAACO,cAAc,EAAE;MAC1B;MACAA,cAAc,GAAG,IAAI;IACvB;EACF;EAEA,OAAOR,GAAG,GAAG,CAAC,GACVL,IAAI,CAACS,WAAW,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,YACzB,GAAG,GACH,GAAG,GACLJ,GAAG,KAAK,CAAC,IAAIL,IAAI,CAACS,WAAW,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,YACtC,IAAI,GACJT,IAAI,CAACU,KAAK,CAAC,CAAC,EAAEL,GAAG,CAAC;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASR,OAAOA,CAACG,IAAI,EAAE;EACrBG,UAAU,CAACH,IAAI,CAAC;EAEhB,IAAIM,KAAK,GAAGN,IAAI,CAACO,MAAM;EAEvB,IAAIF,GAAG,GAAG,CAAC,CAAC;EACZ,IAAIS,SAAS,GAAG,CAAC;EACjB,IAAIC,QAAQ,GAAG,CAAC,CAAC;EACjB;EACA;EACA,IAAIC,WAAW,GAAG,CAAC;EACnB;EACA,IAAIH,cAAc;EAElB,OAAOP,KAAK,EAAE,EAAE;IACd,MAAMW,IAAI,GAAGjB,IAAI,CAACS,WAAW,CAACH,KAAK,CAAC;IAEpC,IAAIW,IAAI,KAAK,EAAE,CAAC,WAAW;MACzB;MACA;MACA,IAAIJ,cAAc,EAAE;QAClBC,SAAS,GAAGR,KAAK,GAAG,CAAC;QACrB;MACF;MAEA;IACF;IAEA,IAAID,GAAG,GAAG,CAAC,EAAE;MACX;MACA;MACAQ,cAAc,GAAG,IAAI;MACrBR,GAAG,GAAGC,KAAK,GAAG,CAAC;IACjB;IAEA,IAAIW,IAAI,KAAK,EAAE,CAAC,WAAW;MACzB;MACA,IAAIF,QAAQ,GAAG,CAAC,EAAE;QAChBA,QAAQ,GAAGT,KAAK;MAClB,CAAC,MAAM,IAAIU,WAAW,KAAK,CAAC,EAAE;QAC5BA,WAAW,GAAG,CAAC;MACjB;IACF,CAAC,MAAM,IAAID,QAAQ,GAAG,CAAC,CAAC,EAAE;MACxB;MACA;MACAC,WAAW,GAAG,CAAC,CAAC;IAClB;EACF;EAEA,IACED,QAAQ,GAAG,CAAC,IACZV,GAAG,GAAG,CAAC;EACP;EACAW,WAAW,KAAK,CAAC;EACjB;EACCA,WAAW,KAAK,CAAC,IAAID,QAAQ,KAAKV,GAAG,GAAG,CAAC,IAAIU,QAAQ,KAAKD,SAAS,GAAG,CAAE,EACzE;IACA,OAAO,EAAE;EACX;EAEA,OAAOd,IAAI,CAACU,KAAK,CAACK,QAAQ,EAAEV,GAAG,CAAC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,IAAIA,CAAC,GAAGoB,QAAQ,EAAE;EACzB,IAAIZ,KAAK,GAAG,CAAC,CAAC;EACd;EACA,IAAIa,MAAM;EAEV,OAAO,EAAEb,KAAK,GAAGY,QAAQ,CAACX,MAAM,EAAE;IAChCJ,UAAU,CAACe,QAAQ,CAACZ,KAAK,CAAC,CAAC;IAE3B,IAAIY,QAAQ,CAACZ,KAAK,CAAC,EAAE;MACnBa,MAAM,GACJA,MAAM,KAAKlB,SAAS,GAAGiB,QAAQ,CAACZ,KAAK,CAAC,GAAGa,MAAM,GAAG,GAAG,GAAGD,QAAQ,CAACZ,KAAK,CAAC;IAC3E;EACF;EAEA,OAAOa,MAAM,KAAKlB,SAAS,GAAG,GAAG,GAAGmB,SAAS,CAACD,MAAM,CAAC;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACpB,IAAI,EAAE;EACvBG,UAAU,CAACH,IAAI,CAAC;EAEhB,MAAMqB,QAAQ,GAAGrB,IAAI,CAACS,WAAW,CAAC,CAAC,CAAC,KAAK,EAAE,EAAC;;EAE5C;EACA,IAAIa,KAAK,GAAGC,eAAe,CAACvB,IAAI,EAAE,CAACqB,QAAQ,CAAC;EAE5C,IAAIC,KAAK,CAACf,MAAM,KAAK,CAAC,IAAI,CAACc,QAAQ,EAAE;IACnCC,KAAK,GAAG,GAAG;EACb;EAEA,IAAIA,KAAK,CAACf,MAAM,GAAG,CAAC,IAAIP,IAAI,CAACS,WAAW,CAACT,IAAI,CAACO,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,SAAS;IACxEe,KAAK,IAAI,GAAG;EACd;EAEA,OAAOD,QAAQ,GAAG,GAAG,GAAGC,KAAK,GAAGA,KAAK;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACvB,IAAI,EAAEwB,cAAc,EAAE;EAC7C,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,iBAAiB,GAAG,CAAC;EACzB,IAAIC,SAAS,GAAG,CAAC,CAAC;EAClB,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAItB,KAAK,GAAG,CAAC,CAAC;EACd;EACA,IAAIW,IAAI;EACR;EACA,IAAIY,cAAc;EAElB,OAAO,EAAEvB,KAAK,IAAIN,IAAI,CAACO,MAAM,EAAE;IAC7B,IAAID,KAAK,GAAGN,IAAI,CAACO,MAAM,EAAE;MACvBU,IAAI,GAAGjB,IAAI,CAACS,WAAW,CAACH,KAAK,CAAC;IAChC,CAAC,MAAM,IAAIW,IAAI,KAAK,EAAE,CAAC,WAAW;MAChC;IACF,CAAC,MAAM;MACLA,IAAI,GAAG,EAAE,EAAC;IACZ;IAEA,IAAIA,IAAI,KAAK,EAAE,CAAC,WAAW;MACzB,IAAIU,SAAS,KAAKrB,KAAK,GAAG,CAAC,IAAIsB,IAAI,KAAK,CAAC,EAAE;QACzC;MAAA,CACD,MAAM,IAAID,SAAS,KAAKrB,KAAK,GAAG,CAAC,IAAIsB,IAAI,KAAK,CAAC,EAAE;QAChD,IACEH,MAAM,CAAClB,MAAM,GAAG,CAAC,IACjBmB,iBAAiB,KAAK,CAAC,IACvBD,MAAM,CAAChB,WAAW,CAACgB,MAAM,CAAClB,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,aAC7CkB,MAAM,CAAChB,WAAW,CAACgB,MAAM,CAAClB,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,WAC7C;UACA,IAAIkB,MAAM,CAAClB,MAAM,GAAG,CAAC,EAAE;YACrBsB,cAAc,GAAGJ,MAAM,CAACK,WAAW,CAAC,GAAG,CAAC;YAExC,IAAID,cAAc,KAAKJ,MAAM,CAAClB,MAAM,GAAG,CAAC,EAAE;cACxC,IAAIsB,cAAc,GAAG,CAAC,EAAE;gBACtBJ,MAAM,GAAG,EAAE;gBACXC,iBAAiB,GAAG,CAAC;cACvB,CAAC,MAAM;gBACLD,MAAM,GAAGA,MAAM,CAACf,KAAK,CAAC,CAAC,EAAEmB,cAAc,CAAC;gBACxCH,iBAAiB,GAAGD,MAAM,CAAClB,MAAM,GAAG,CAAC,GAAGkB,MAAM,CAACK,WAAW,CAAC,GAAG,CAAC;cACjE;cAEAH,SAAS,GAAGrB,KAAK;cACjBsB,IAAI,GAAG,CAAC;cACR;YACF;UACF,CAAC,MAAM,IAAIH,MAAM,CAAClB,MAAM,GAAG,CAAC,EAAE;YAC5BkB,MAAM,GAAG,EAAE;YACXC,iBAAiB,GAAG,CAAC;YACrBC,SAAS,GAAGrB,KAAK;YACjBsB,IAAI,GAAG,CAAC;YACR;UACF;QACF;QAEA,IAAIJ,cAAc,EAAE;UAClBC,MAAM,GAAGA,MAAM,CAAClB,MAAM,GAAG,CAAC,GAAGkB,MAAM,GAAG,KAAK,GAAG,IAAI;UAClDC,iBAAiB,GAAG,CAAC;QACvB;MACF,CAAC,MAAM;QACL,IAAID,MAAM,CAAClB,MAAM,GAAG,CAAC,EAAE;UACrBkB,MAAM,IAAI,GAAG,GAAGzB,IAAI,CAACU,KAAK,CAACiB,SAAS,GAAG,CAAC,EAAErB,KAAK,CAAC;QAClD,CAAC,MAAM;UACLmB,MAAM,GAAGzB,IAAI,CAACU,KAAK,CAACiB,SAAS,GAAG,CAAC,EAAErB,KAAK,CAAC;QAC3C;QAEAoB,iBAAiB,GAAGpB,KAAK,GAAGqB,SAAS,GAAG,CAAC;MAC3C;MAEAA,SAAS,GAAGrB,KAAK;MACjBsB,IAAI,GAAG,CAAC;IACV,CAAC,MAAM,IAAIX,IAAI,KAAK,EAAE,CAAC,aAAaW,IAAI,GAAG,CAAC,CAAC,EAAE;MAC7CA,IAAI,EAAE;IACR,CAAC,MAAM;MACLA,IAAI,GAAG,CAAC,CAAC;IACX;EACF;EAEA,OAAOH,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStB,UAAUA,CAACH,IAAI,EAAE;EACxB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,MAAM,IAAIE,SAAS,CACjB,kCAAkC,GAAG6B,IAAI,CAACC,SAAS,CAAChC,IAAI,CAC1D,CAAC;EACH;AACF;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}